"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getLocalExtensions = exports.getPackageExtensions = exports.resolvePackageExtensions = void 0;
const path_1 = __importDefault(require("path"));
const fs_extra_1 = __importDefault(require("fs-extra"));
const types_1 = require("../../types");
const resolve_package_1 = require("./resolve-package");
const list_folders_1 = require("./list-folders");
const constants_1 = require("../../constants");
const pluralize_1 = require("../pluralize");
const array_helpers_1 = require("../array-helpers");
async function resolvePackageExtensions(root, extensionNames) {
    const extensions = [];
    const local = extensionNames === undefined;
    if (extensionNames === undefined) {
        extensionNames = await (0, list_folders_1.listFolders)(root);
        extensionNames = extensionNames.filter((name) => constants_1.EXTENSION_NAME_REGEX.test(name));
    }
    for (const extensionName of extensionNames) {
        const extensionPath = local ? path_1.default.join(root, extensionName) : (0, resolve_package_1.resolvePackage)(extensionName, root);
        const extensionManifest = await fs_extra_1.default.readJSON(path_1.default.join(extensionPath, 'package.json'));
        let parsedManifest;
        try {
            parsedManifest = types_1.ExtensionManifest.parse(extensionManifest);
        }
        catch (error) {
            throw new Error(`The extension manifest of "${extensionName}" is not valid.\n${error}`);
        }
        const extensionOptions = parsedManifest[constants_1.EXTENSION_PKG_KEY];
        if (extensionOptions.type === 'bundle') {
            extensions.push({
                path: extensionPath,
                name: parsedManifest.name,
                version: parsedManifest.version,
                type: extensionOptions.type,
                entrypoint: {
                    app: extensionOptions.path.app,
                    api: extensionOptions.path.api,
                },
                entries: extensionOptions.entries,
                host: extensionOptions.host,
                local,
            });
        }
        else if ((0, array_helpers_1.isTypeIn)(extensionOptions, constants_1.HYBRID_EXTENSION_TYPES)) {
            extensions.push({
                path: extensionPath,
                name: parsedManifest.name,
                version: parsedManifest.version,
                type: extensionOptions.type,
                entrypoint: {
                    app: extensionOptions.path.app,
                    api: extensionOptions.path.api,
                },
                host: extensionOptions.host,
                local,
            });
        }
        else {
            extensions.push({
                path: extensionPath,
                name: parsedManifest.name,
                version: parsedManifest.version,
                type: extensionOptions.type,
                entrypoint: extensionOptions.path,
                host: extensionOptions.host,
                local,
            });
        }
    }
    return extensions;
}
exports.resolvePackageExtensions = resolvePackageExtensions;
async function getPackageExtensions(root) {
    var _a;
    let pkg;
    try {
        pkg = await fs_extra_1.default.readJSON(path_1.default.resolve(root, 'package.json'));
    }
    catch {
        throw new Error('Current folder does not contain a package.json file');
    }
    const extensionNames = Object.keys((_a = pkg.dependencies) !== null && _a !== void 0 ? _a : {}).filter((dep) => constants_1.EXTENSION_NAME_REGEX.test(dep));
    return resolvePackageExtensions(root, extensionNames);
}
exports.getPackageExtensions = getPackageExtensions;
async function getLocalExtensions(root) {
    const extensions = [];
    for (const extensionType of constants_1.NESTED_EXTENSION_TYPES) {
        const typeDir = (0, pluralize_1.pluralize)(extensionType);
        const typePath = path_1.default.resolve(root, typeDir);
        try {
            const extensionNames = await (0, list_folders_1.listFolders)(typePath);
            for (const extensionName of extensionNames) {
                const extensionPath = path_1.default.join(typePath, extensionName);
                if ((0, array_helpers_1.isIn)(extensionType, constants_1.HYBRID_EXTENSION_TYPES)) {
                    extensions.push({
                        path: extensionPath,
                        name: extensionName,
                        type: extensionType,
                        entrypoint: {
                            app: 'app.js',
                            api: 'api.js',
                        },
                        local: true,
                    });
                }
                else {
                    extensions.push({
                        path: extensionPath,
                        name: extensionName,
                        type: extensionType,
                        entrypoint: 'index.js',
                        local: true,
                    });
                }
            }
        }
        catch (e) {
            throw new Error(`Extension folder "${typePath}" couldn't be opened`);
        }
    }
    return extensions;
}
exports.getLocalExtensions = getLocalExtensions;
