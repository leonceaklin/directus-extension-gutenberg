{"version":3,"sources":["@wordpress/annotations/src/store/selectors.js"],"names":["createSelector","EMPTY_ARRAY","__experimentalGetAnnotationsForBlock","state","blockClientId","filter","annotation","selector","__experimentalGetAllAnnotationsForBlock","__experimentalGetAnnotationsForRichText","richTextIdentifier","map","range","other","__experimentalGetAnnotations","Object","values","flat"],"mappings":"AAAA;AACA;AACA;AACA,OAAOA,cAAP,MAA2B,QAA3B;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,MAAMC,WAAW,GAAG,EAApB;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,MAAMC,oCAAoC,GAAGF,cAAc,CACjE,CAAEG,KAAF,EAASC,aAAT,KAA4B;AAAA;;AAC3B,SAAO,yBAAED,KAAF,aAAEA,KAAF,uBAAEA,KAAK,CAAIC,aAAJ,CAAP,uEAA8B,EAA9B,EAAmCC,MAAnC,CAA6CC,UAAF,IAAkB;AACnE,WAAOA,UAAU,CAACC,QAAX,KAAwB,OAA/B;AACA,GAFM,CAAP;AAGA,CALgE,EAMjE,CAAEJ,KAAF,EAASC,aAAT;AAAA;;AAAA,SAA4B,0BAAED,KAAF,aAAEA,KAAF,uBAAEA,KAAK,CAAIC,aAAJ,CAAP,yEAA8BH,WAA9B,CAA5B;AAAA,CANiE,CAA3D;AASP,OAAO,SAASO,uCAAT,CACNL,KADM,EAENC,aAFM,EAGL;AAAA;;AACD,kCAAOD,KAAP,aAAOA,KAAP,uBAAOA,KAAK,CAAIC,aAAJ,CAAZ,yEAAmCH,WAAnC;AACA;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,MAAMQ,uCAAuC,GAAGT,cAAc,CACpE,CAAEG,KAAF,EAASC,aAAT,EAAwBM,kBAAxB,KAAgD;AAAA;;AAC/C,SAAO,0BAAEP,KAAF,aAAEA,KAAF,uBAAEA,KAAK,CAAIC,aAAJ,CAAP,yEAA8B,EAA9B,EACLC,MADK,CACKC,UAAF,IAAkB;AAC1B,WACCA,UAAU,CAACC,QAAX,KAAwB,OAAxB,IACAG,kBAAkB,KAAKJ,UAAU,CAACI,kBAFnC;AAIA,GANK,EAOLC,GAPK,CAOEL,UAAF,IAAkB;AACvB,UAAM;AAAEM,MAAAA,KAAF;AAAS,SAAGC;AAAZ,QAAsBP,UAA5B;AAEA,WAAO,EACN,GAAGM,KADG;AAEN,SAAGC;AAFG,KAAP;AAIA,GAdK,CAAP;AAeA,CAjBmE,EAkBpE,CAAEV,KAAF,EAASC,aAAT;AAAA;;AAAA,SAA4B,0BAAED,KAAF,aAAEA,KAAF,uBAAEA,KAAK,CAAIC,aAAJ,CAAP,yEAA8BH,WAA9B,CAA5B;AAAA,CAlBoE,CAA9D;AAqBP;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASa,4BAAT,CAAuCX,KAAvC,EAA+C;AACrD,SAAOY,MAAM,CAACC,MAAP,CAAeb,KAAf,EAAuBc,IAAvB,EAAP;AACA","sourcesContent":["/**\n * External dependencies\n */\nimport createSelector from 'rememo';\n\n/**\n * Shared reference to an empty array for cases where it is important to avoid\n * returning a new array reference on every invocation, as in a connected or\n * other pure component which performs `shouldComponentUpdate` check on props.\n * This should be used as a last resort, since the normalized data should be\n * maintained by the reducer result in state.\n *\n * @type {Array}\n */\nconst EMPTY_ARRAY = [];\n\n/**\n * Returns the annotations for a specific client ID.\n *\n * @param {Object} state    Editor state.\n * @param {string} clientId The ID of the block to get the annotations for.\n *\n * @return {Array} The annotations applicable to this block.\n */\nexport const __experimentalGetAnnotationsForBlock = createSelector(\n\t( state, blockClientId ) => {\n\t\treturn ( state?.[ blockClientId ] ?? [] ).filter( ( annotation ) => {\n\t\t\treturn annotation.selector === 'block';\n\t\t} );\n\t},\n\t( state, blockClientId ) => [ state?.[ blockClientId ] ?? EMPTY_ARRAY ]\n);\n\nexport function __experimentalGetAllAnnotationsForBlock(\n\tstate,\n\tblockClientId\n) {\n\treturn state?.[ blockClientId ] ?? EMPTY_ARRAY;\n}\n\n/**\n * Returns the annotations that apply to the given RichText instance.\n *\n * Both a blockClientId and a richTextIdentifier are required. This is because\n * a block might have multiple `RichText` components. This does mean that every\n * block needs to implement annotations itself.\n *\n * @param {Object} state              Editor state.\n * @param {string} blockClientId      The client ID for the block.\n * @param {string} richTextIdentifier Unique identifier that identifies the given RichText.\n * @return {Array} All the annotations relevant for the `RichText`.\n */\nexport const __experimentalGetAnnotationsForRichText = createSelector(\n\t( state, blockClientId, richTextIdentifier ) => {\n\t\treturn ( state?.[ blockClientId ] ?? [] )\n\t\t\t.filter( ( annotation ) => {\n\t\t\t\treturn (\n\t\t\t\t\tannotation.selector === 'range' &&\n\t\t\t\t\trichTextIdentifier === annotation.richTextIdentifier\n\t\t\t\t);\n\t\t\t} )\n\t\t\t.map( ( annotation ) => {\n\t\t\t\tconst { range, ...other } = annotation;\n\n\t\t\t\treturn {\n\t\t\t\t\t...range,\n\t\t\t\t\t...other,\n\t\t\t\t};\n\t\t\t} );\n\t},\n\t( state, blockClientId ) => [ state?.[ blockClientId ] ?? EMPTY_ARRAY ]\n);\n\n/**\n * Returns all annotations in the editor state.\n *\n * @param {Object} state Editor state.\n * @return {Array} All annotations currently applied.\n */\nexport function __experimentalGetAnnotations( state ) {\n\treturn Object.values( state ).flat();\n}\n"]}