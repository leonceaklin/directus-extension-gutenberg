"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = Preview;

var _element = require("@wordpress/element");

var _classnames = _interopRequireDefault(require("classnames"));

var _compose = require("@wordpress/compose");

var _components = require("@wordpress/components");

var _i18n = require("@wordpress/i18n");

var _apiFetch = _interopRequireDefault(require("@wordpress/api-fetch"));

/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */
function Preview(_ref) {
  let {
    idBase,
    instance,
    isVisible
  } = _ref;
  const [isLoaded, setIsLoaded] = (0, _element.useState)(false);
  const [srcDoc, setSrcDoc] = (0, _element.useState)('');
  (0, _element.useEffect)(() => {
    const abortController = typeof window.AbortController === 'undefined' ? undefined : new window.AbortController();

    async function fetchPreviewHTML() {
      const restRoute = `/wp/v2/widget-types/${idBase}/render`;
      return await (0, _apiFetch.default)({
        path: restRoute,
        method: 'POST',
        signal: abortController === null || abortController === void 0 ? void 0 : abortController.signal,
        data: instance ? {
          instance
        } : {}
      });
    }

    fetchPreviewHTML().then(response => {
      setSrcDoc(response.preview);
    }).catch(error => {
      if ('AbortError' === error.name) {
        // We don't want to log aborted requests.
        return;
      }

      throw error;
    });
    return () => abortController === null || abortController === void 0 ? void 0 : abortController.abort();
  }, [idBase, instance]); // Resize the iframe on either the load event, or when the iframe becomes visible.

  const ref = (0, _compose.useRefEffect)(iframe => {
    // Only set height if the iframe is loaded,
    // or it will grow to an unexpected large height in Safari if it's hidden initially.
    if (!isLoaded) {
      return;
    } // If the preview frame has another origin then this won't work.
    // One possible solution is to add custom script to call `postMessage` in the preview frame.
    // Or, better yet, we migrate away from iframe.


    function setHeight() {
      var _iframe$contentDocume, _iframe$contentDocume2, _iframe$contentDocume3, _iframe$contentDocume4;

      // Pick the maximum of these two values to account for margin collapsing.
      const height = Math.max((_iframe$contentDocume = (_iframe$contentDocume2 = iframe.contentDocument.documentElement) === null || _iframe$contentDocume2 === void 0 ? void 0 : _iframe$contentDocume2.offsetHeight) !== null && _iframe$contentDocume !== void 0 ? _iframe$contentDocume : 0, (_iframe$contentDocume3 = (_iframe$contentDocume4 = iframe.contentDocument.body) === null || _iframe$contentDocume4 === void 0 ? void 0 : _iframe$contentDocume4.offsetHeight) !== null && _iframe$contentDocume3 !== void 0 ? _iframe$contentDocume3 : 0); // Fallback to a height of 100px if the height cannot be determined.
      // This ensures the block is still selectable. 100px should hopefully
      // be not so big that it's annoying, and not so small that nothing
      // can be seen.

      iframe.style.height = `${height !== 0 ? height : 100}px`;
    }

    const {
      IntersectionObserver
    } = iframe.ownerDocument.defaultView; // Observe for intersections that might cause a change in the height of
    // the iframe, e.g. a Widget Area becoming expanded.

    const intersectionObserver = new IntersectionObserver(_ref2 => {
      let [entry] = _ref2;

      if (entry.isIntersecting) {
        setHeight();
      }
    }, {
      threshold: 1
    });
    intersectionObserver.observe(iframe);
    iframe.addEventListener('load', setHeight);
    return () => {
      intersectionObserver.disconnect();
      iframe.removeEventListener('load', setHeight);
    };
  }, [isLoaded]);
  return (0, _element.createElement)(_element.Fragment, null, isVisible && !isLoaded && (0, _element.createElement)(_components.Placeholder, null, (0, _element.createElement)(_components.Spinner, null)), (0, _element.createElement)("div", {
    className: (0, _classnames.default)('wp-block-legacy-widget__edit-preview', {
      'is-offscreen': !isVisible || !isLoaded
    })
  }, (0, _element.createElement)(_components.Disabled, null, (0, _element.createElement)("iframe", {
    ref: ref,
    className: "wp-block-legacy-widget__edit-preview-iframe",
    tabIndex: "-1",
    title: (0, _i18n.__)('Legacy Widget Preview'),
    srcDoc: srcDoc,
    onLoad: event => {
      // To hide the scrollbars of the preview frame for some edge cases,
      // such as negative margins in the Gallery Legacy Widget.
      // It can't be scrolled anyway.
      // TODO: Ideally, this should be fixed in core.
      event.target.contentDocument.body.style.overflow = 'hidden';
      setIsLoaded(true);
    },
    height: 100
  }))));
}
//# sourceMappingURL=preview.js.map