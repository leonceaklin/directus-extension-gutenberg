"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = InlineColorUI;
exports.getActiveColors = getActiveColors;
exports.parseClassName = parseClassName;

var _element = require("@wordpress/element");

var _data = require("@wordpress/data");

var _richText = require("@wordpress/rich-text");

var _blockEditor = require("@wordpress/block-editor");

var _components = require("@wordpress/components");

var _i18n = require("@wordpress/i18n");

var _index = require("./index");

/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */
function parseCSS() {
  let css = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
  return css.split(';').reduce((accumulator, rule) => {
    if (rule) {
      const [property, value] = rule.split(':');
      if (property === 'color') accumulator.color = value;
      if (property === 'background-color' && value !== _index.transparentValue) accumulator.backgroundColor = value;
    }

    return accumulator;
  }, {});
}

function parseClassName() {
  let className = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
  let colorSettings = arguments.length > 1 ? arguments[1] : undefined;
  return className.split(' ').reduce((accumulator, name) => {
    // `colorSlug` could contain dashes, so simply match the start and end.
    if (name.startsWith('has-') && name.endsWith('-color')) {
      const colorSlug = name.replace(/^has-/, '').replace(/-color$/, '');
      const colorObject = (0, _blockEditor.getColorObjectByAttributeValues)(colorSettings, colorSlug);
      accumulator.color = colorObject.color;
    }

    return accumulator;
  }, {});
}

function getActiveColors(value, name, colorSettings) {
  const activeColorFormat = (0, _richText.getActiveFormat)(value, name);

  if (!activeColorFormat) {
    return {};
  }

  return { ...parseCSS(activeColorFormat.attributes.style),
    ...parseClassName(activeColorFormat.attributes.class, colorSettings)
  };
}

function setColors(value, name, colorSettings, colors) {
  const {
    color,
    backgroundColor
  } = { ...getActiveColors(value, name, colorSettings),
    ...colors
  };

  if (!color && !backgroundColor) {
    return (0, _richText.removeFormat)(value, name);
  }

  const styles = [];
  const classNames = [];
  const attributes = {};

  if (backgroundColor) {
    styles.push(['background-color', backgroundColor].join(':'));
  } else {
    // Override default browser color for mark element.
    styles.push(['background-color', _index.transparentValue].join(':'));
  }

  if (color) {
    const colorObject = (0, _blockEditor.getColorObjectByColorValue)(colorSettings, color);

    if (colorObject) {
      classNames.push((0, _blockEditor.getColorClassName)('color', colorObject.slug));
    } else {
      styles.push(['color', color].join(':'));
    }
  }

  if (styles.length) attributes.style = styles.join(';');
  if (classNames.length) attributes.class = classNames.join(' ');
  return (0, _richText.applyFormat)(value, {
    type: name,
    attributes
  });
}

function ColorPicker(_ref) {
  let {
    name,
    property,
    value,
    onChange
  } = _ref;
  const colors = (0, _data.useSelect)(select => {
    var _getSettings$colors;

    const {
      getSettings
    } = select(_blockEditor.store);
    return (_getSettings$colors = getSettings().colors) !== null && _getSettings$colors !== void 0 ? _getSettings$colors : [];
  }, []);
  const onColorChange = (0, _element.useCallback)(color => {
    onChange(setColors(value, name, colors, {
      [property]: color
    }));
  }, [colors, onChange, property]);
  const activeColors = (0, _element.useMemo)(() => getActiveColors(value, name, colors), [name, value, colors]);
  return (0, _element.createElement)(_blockEditor.ColorPalette, {
    value: activeColors[property],
    onChange: onColorChange
  });
}

function InlineColorUI(_ref2) {
  let {
    name,
    value,
    onChange,
    onClose,
    contentRef
  } = _ref2;

  /*
   As you change the text color by typing a HEX value into a field,
   the return value of document.getSelection jumps to the field you're editing,
   not the highlighted text. Given that useAnchor uses document.getSelection,
   it will return null, since it can't find the <mark> element within the HEX input.
   This caches the last truthy value of the selection anchor reference.
   */
  const popoverAnchor = (0, _blockEditor.useCachedTruthy)((0, _richText.useAnchor)({
    editableContentElement: contentRef.current,
    value,
    settings: _index.textColor
  }));
  return (0, _element.createElement)(_components.Popover, {
    onClose: onClose,
    className: "components-inline-color-popover",
    anchor: popoverAnchor
  }, (0, _element.createElement)(_components.TabPanel, {
    tabs: [{
      name: 'color',
      title: (0, _i18n.__)('Text')
    }, {
      name: 'backgroundColor',
      title: (0, _i18n.__)('Background')
    }]
  }, tab => (0, _element.createElement)(ColorPicker, {
    name: name,
    property: tab.name,
    value: value,
    onChange: onChange
  })));
}
//# sourceMappingURL=inline.js.map