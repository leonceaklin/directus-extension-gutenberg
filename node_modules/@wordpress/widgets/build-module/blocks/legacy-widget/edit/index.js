import { createElement, Fragment } from "@wordpress/element";

/**
 * External dependencies
 */
import classnames from 'classnames';
/**
 * WordPress dependencies
 */

import { useBlockProps, BlockControls, InspectorControls, BlockIcon, store as blockEditorStore } from '@wordpress/block-editor';
import { Flex, FlexBlock, Spinner, Placeholder } from '@wordpress/components';
import { brush as brushIcon } from '@wordpress/icons';
import { __ } from '@wordpress/i18n';
import { useState, useCallback } from '@wordpress/element';
import { useSelect } from '@wordpress/data';
import { useEntityRecord } from '@wordpress/core-data';
/**
 * Internal dependencies
 */

import WidgetTypeSelector from './widget-type-selector';
import InspectorCard from './inspector-card';
import Form from './form';
import Preview from './preview';
import NoPreview from './no-preview';
import ConvertToBlocksButton from './convert-to-blocks-button';
export default function Edit(props) {
  const {
    id,
    idBase
  } = props.attributes;
  const {
    isWide = false
  } = props;
  const blockProps = useBlockProps({
    className: classnames({
      'is-wide-widget': isWide
    })
  });
  return createElement("div", blockProps, !id && !idBase ? createElement(Empty, props) : createElement(NotEmpty, props));
}

function Empty(_ref) {
  let {
    attributes: {
      id,
      idBase
    },
    setAttributes
  } = _ref;
  return createElement(Placeholder, {
    icon: createElement(BlockIcon, {
      icon: brushIcon
    }),
    label: __('Legacy Widget')
  }, createElement(Flex, null, createElement(FlexBlock, null, createElement(WidgetTypeSelector, {
    selectedId: id !== null && id !== void 0 ? id : idBase,
    onSelect: _ref2 => {
      let {
        selectedId,
        isMulti
      } = _ref2;

      if (!selectedId) {
        setAttributes({
          id: null,
          idBase: null,
          instance: null
        });
      } else if (isMulti) {
        setAttributes({
          id: null,
          idBase: selectedId,
          instance: {}
        });
      } else {
        setAttributes({
          id: selectedId,
          idBase: null,
          instance: null
        });
      }
    }
  }))));
}

function NotEmpty(_ref3) {
  let {
    attributes: {
      id,
      idBase,
      instance
    },
    setAttributes,
    clientId,
    isSelected,
    isWide = false
  } = _ref3;
  const [hasPreview, setHasPreview] = useState(null);
  const widgetTypeId = id !== null && id !== void 0 ? id : idBase;
  const {
    record: widgetType,
    hasResolved: hasResolvedWidgetType
  } = useEntityRecord('root', 'widgetType', widgetTypeId);
  const isNavigationMode = useSelect(select => select(blockEditorStore).isNavigationMode(), []);
  const setInstance = useCallback(nextInstance => {
    setAttributes({
      instance: nextInstance
    });
  }, []);

  if (!widgetType && hasResolvedWidgetType) {
    return createElement(Placeholder, {
      icon: createElement(BlockIcon, {
        icon: brushIcon
      }),
      label: __('Legacy Widget')
    }, __('Widget is missing.'));
  }

  if (!hasResolvedWidgetType) {
    return createElement(Placeholder, null, createElement(Spinner, null));
  }

  const mode = idBase && (isNavigationMode || !isSelected) ? 'preview' : 'edit';
  return createElement(Fragment, null, idBase === 'text' && createElement(BlockControls, {
    group: "other"
  }, createElement(ConvertToBlocksButton, {
    clientId: clientId,
    rawInstance: instance.raw
  })), createElement(InspectorControls, null, createElement(InspectorCard, {
    name: widgetType.name,
    description: widgetType.description
  })), createElement(Form, {
    title: widgetType.name,
    isVisible: mode === 'edit',
    id: id,
    idBase: idBase,
    instance: instance,
    isWide: isWide,
    onChangeInstance: setInstance,
    onChangeHasPreview: setHasPreview
  }), idBase && createElement(Fragment, null, hasPreview === null && mode === 'preview' && createElement(Placeholder, null, createElement(Spinner, null)), hasPreview === true && createElement(Preview, {
    idBase: idBase,
    instance: instance,
    isVisible: mode === 'preview'
  }), hasPreview === false && mode === 'preview' && createElement(NoPreview, {
    name: widgetType.name
  })));
}
//# sourceMappingURL=index.js.map