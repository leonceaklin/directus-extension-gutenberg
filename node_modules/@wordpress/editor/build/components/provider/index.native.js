"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _element = require("@wordpress/element");

var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));

var _memize = _interopRequireDefault(require("memize"));

var _reactNativeSafeAreaContext = require("react-native-safe-area-context");

var _reactNativeBridge = _interopRequireWildcard(require("@wordpress/react-native-bridge"));

var _wordcount = require("@wordpress/wordcount");

var _blocks = require("@wordpress/blocks");

var _data = require("@wordpress/data");

var _compose = require("@wordpress/compose");

var _hooks = require("@wordpress/hooks");

var _blockEditor = require("@wordpress/block-editor");

var _components = require("@wordpress/components");

var _blockLibrary = require("@wordpress/block-library");

var _editor = require("@wordpress/editor");

var _notices = require("@wordpress/notices");

var _coreData = require("@wordpress/core-data");

var _editPost = require("@wordpress/edit-post");

var _index = _interopRequireDefault(require("./index.js"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */
const postTypeEntities = [{
  name: 'post',
  baseURL: '/wp/v2/posts'
}, {
  name: 'page',
  baseURL: '/wp/v2/pages'
}, {
  name: 'attachment',
  baseURL: '/wp/v2/media'
}, {
  name: 'wp_block',
  baseURL: '/wp/v2/blocks'
}].map(postTypeEntity => ({
  kind: 'postType',
  ...postTypeEntity,
  transientEdits: {
    blocks: true,
    selection: true
  },
  mergedEdits: {
    meta: true
  },
  rawAttributes: ['title', 'excerpt', 'content']
}));

class NativeEditorProvider extends _element.Component {
  constructor() {
    super(...arguments); // Keep a local reference to `post` to detect changes.

    this.post = this.props.post;
    this.props.addEntities(postTypeEntities);
    this.props.receiveEntityRecords('postType', this.post.type, this.post);
    this.getEditorSettings = (0, _memize.default)((settings, capabilities) => ({ ...settings,
      capabilities
    }), {
      maxSize: 1
    });
    this.state = {
      isHelpVisible: false
    };
  }

  componentDidMount() {
    const {
      capabilities,
      locale,
      hostAppNamespace,
      updateSettings
    } = this.props;
    updateSettings({ ...capabilities,
      ...this.getThemeColors(this.props),
      locale,
      hostAppNamespace
    });
    this.subscriptionParentGetHtml = (0, _reactNativeBridge.subscribeParentGetHtml)(() => {
      this.serializeToNativeAction();
    });
    this.subscriptionParentToggleHTMLMode = (0, _reactNativeBridge.subscribeParentToggleHTMLMode)(() => {
      this.toggleMode();
    });
    this.subscriptionParentSetTitle = (0, _reactNativeBridge.subscribeSetTitle)(payload => {
      this.props.editTitle(payload.title);
    });
    this.subscriptionParentUpdateHtml = (0, _reactNativeBridge.subscribeUpdateHtml)(payload => {
      this.updateHtmlAction(payload.html);
    });
    this.subscriptionParentReplaceBlock = (0, _reactNativeBridge.subscribeReplaceBlock)(payload => {
      this.replaceBlockAction(payload.html, payload.clientId);
    });
    this.subscriptionParentMediaAppend = (0, _reactNativeBridge.subscribeMediaAppend)(payload => {
      const blockName = 'core/' + payload.mediaType;
      const newBlock = (0, _blocks.createBlock)(blockName, {
        id: payload.mediaId,
        [payload.mediaType === 'image' ? 'url' : 'src']: payload.mediaUrl
      });
      const indexAfterSelected = this.props.selectedBlockIndex + 1;
      const insertionIndex = indexAfterSelected || this.props.blockCount;
      this.props.insertBlock(newBlock, insertionIndex);
    });
    this.subscriptionParentUpdateEditorSettings = (0, _reactNativeBridge.subscribeUpdateEditorSettings)(_ref => {
      let {
        galleryWithImageBlocks,
        ...editorSettings
      } = _ref;

      if (typeof galleryWithImageBlocks === 'boolean') {
        window.wp.galleryBlockV2Enabled = galleryWithImageBlocks;
      }

      updateSettings(this.getThemeColors(editorSettings));
    });
    this.subscriptionParentUpdateCapabilities = (0, _reactNativeBridge.subscribeUpdateCapabilities)(payload => {
      this.updateCapabilitiesAction(payload);
    });
    this.subscriptionParentShowNotice = (0, _reactNativeBridge.subscribeShowNotice)(payload => {
      this.props.createSuccessNotice(payload.message);
    });
    this.subscriptionParentShowEditorHelp = (0, _reactNativeBridge.subscribeShowEditorHelp)(() => {
      this.setState({
        isHelpVisible: true
      });
    }); // Request current block impressions from native app.

    (0, _reactNativeBridge.requestBlockTypeImpressions)(storedImpressions => {
      const impressions = { ..._blockLibrary.NEW_BLOCK_TYPES,
        ...storedImpressions
      }; // Persist impressions to JavaScript store.

      updateSettings({
        impressions
      }); // Persist impressions to native store if they do not include latest
      // `NEW_BLOCK_TYPES` configuration.

      const storedImpressionKeys = Object.keys(storedImpressions);
      const storedImpressionsCurrent = Object.keys(_blockLibrary.NEW_BLOCK_TYPES).every(newKey => storedImpressionKeys.includes(newKey));

      if (!storedImpressionsCurrent) {
        (0, _reactNativeBridge.setBlockTypeImpressions)(impressions);
      }
    });
  }

  componentWillUnmount() {
    if (this.subscriptionParentGetHtml) {
      this.subscriptionParentGetHtml.remove();
    }

    if (this.subscriptionParentToggleHTMLMode) {
      this.subscriptionParentToggleHTMLMode.remove();
    }

    if (this.subscriptionParentSetTitle) {
      this.subscriptionParentSetTitle.remove();
    }

    if (this.subscriptionParentUpdateHtml) {
      this.subscriptionParentUpdateHtml.remove();
    }

    if (this.subscriptionParentReplaceBlock) {
      this.subscriptionParentReplaceBlock.remove();
    }

    if (this.subscriptionParentMediaAppend) {
      this.subscriptionParentMediaAppend.remove();
    }

    if (this.subscriptionParentUpdateEditorSettings) {
      this.subscriptionParentUpdateEditorSettings.remove();
    }

    if (this.subscriptionParentUpdateCapabilities) {
      this.subscriptionParentUpdateCapabilities.remove();
    }

    if (this.subscriptionParentShowNotice) {
      this.subscriptionParentShowNotice.remove();
    }

    if (this.subscriptionParentShowEditorHelp) {
      this.subscriptionParentShowEditorHelp.remove();
    }
  }

  getThemeColors(_ref2) {
    let {
      rawStyles,
      rawFeatures
    } = _ref2;
    const {
      defaultEditorColors,
      defaultEditorGradients
    } = this.props;

    if (rawStyles && rawFeatures) {
      return (0, _components.getGlobalStyles)(rawStyles, rawFeatures);
    }

    return (0, _components.getColorsAndGradients)(defaultEditorColors, defaultEditorGradients, rawFeatures);
  }

  componentDidUpdate(prevProps) {
    if (!prevProps.isReady && this.props.isReady) {
      const blocks = this.props.blocks;

      const isUnsupportedBlock = _ref3 => {
        let {
          name
        } = _ref3;
        return name === (0, _blocks.getUnregisteredTypeHandlerName)();
      };

      const unsupportedBlockNames = blocks.filter(isUnsupportedBlock).map(block => block.attributes.originalName);

      _reactNativeBridge.default.editorDidMount(unsupportedBlockNames);
    }
  }

  serializeToNativeAction() {
    const title = this.props.title;
    let html;

    if (this.props.mode === 'text') {
      // The HTMLTextInput component does not update the store when user is doing changes
      // Let's request the HTML from the component's state directly.
      html = (0, _hooks.applyFilters)('native.persist-html');
    } else {
      html = (0, _blocks.serialize)(this.props.blocks);
    }

    const hasChanges = title !== this.post.title.raw || html !== this.post.content.raw; // Variable to store the content structure metrics.

    const contentInfo = {};
    contentInfo.characterCount = (0, _wordcount.count)(html, 'characters_including_spaces');
    contentInfo.wordCount = (0, _wordcount.count)(html, 'words');
    contentInfo.paragraphCount = this.props.paragraphCount;
    contentInfo.blockCount = this.props.blockCount;

    _reactNativeBridge.default.provideToNative_Html(html, title, hasChanges, contentInfo);

    if (hasChanges) {
      this.post.title.raw = title;
      this.post.content.raw = html;
    }
  }

  updateHtmlAction(html) {
    const parsed = (0, _blocks.parse)(html);
    this.props.resetEditorBlocksWithoutUndoLevel(parsed);
  }

  replaceBlockAction(html, blockClientId) {
    const parsed = (0, _blocks.parse)(html);
    this.props.replaceBlock(blockClientId, parsed);
  }

  toggleMode() {
    const {
      mode,
      switchMode
    } = this.props; // Refresh html content first.

    this.serializeToNativeAction(); // Make sure to blur the selected block and dismiss the keyboard.

    this.props.clearSelectedBlock();
    switchMode(mode === 'visual' ? 'text' : 'visual');
  }

  updateCapabilitiesAction(capabilities) {
    this.props.updateSettings(capabilities);
  }

  render() {
    const {
      children,
      post,
      capabilities,
      settings,
      ...props
    } = this.props;
    const editorSettings = this.getEditorSettings(settings, capabilities);
    return (0, _element.createElement)(_element.Fragment, null, (0, _element.createElement)(_index.default, (0, _extends2.default)({
      post: this.post,
      settings: editorSettings
    }, props), (0, _element.createElement)(_reactNativeSafeAreaContext.SafeAreaProvider, null, children)), (0, _element.createElement)(_editor.EditorHelpTopics, {
      isVisible: this.state.isHelpVisible,
      onClose: () => this.setState({
        isHelpVisible: false
      }),
      close: () => this.setState({
        isHelpVisible: false
      }),
      showSupport: (capabilities === null || capabilities === void 0 ? void 0 : capabilities.supportSection) === true
    }));
  }

}

var _default = (0, _compose.compose)([(0, _data.withSelect)(select => {
  var _settings$colors, _settings$gradients;

  const {
    __unstableIsEditorReady: isEditorReady,
    getEditorBlocks,
    getEditedPostAttribute,
    getEditedPostContent
  } = select(_editor.store);
  const {
    getEditorMode
  } = select(_editPost.store);
  const {
    getBlockIndex,
    getSelectedBlockClientId,
    getGlobalBlockCount,
    getSettings: getBlockEditorSettings
  } = select(_blockEditor.store);
  const settings = getBlockEditorSettings();
  const defaultEditorColors = (_settings$colors = settings === null || settings === void 0 ? void 0 : settings.colors) !== null && _settings$colors !== void 0 ? _settings$colors : [];
  const defaultEditorGradients = (_settings$gradients = settings === null || settings === void 0 ? void 0 : settings.gradients) !== null && _settings$gradients !== void 0 ? _settings$gradients : [];
  const selectedBlockClientId = getSelectedBlockClientId();
  return {
    mode: getEditorMode(),
    isReady: isEditorReady(),
    blocks: getEditorBlocks(),
    title: getEditedPostAttribute('title'),
    getEditedPostContent,
    defaultEditorColors,
    defaultEditorGradients,
    selectedBlockIndex: getBlockIndex(selectedBlockClientId),
    blockCount: getGlobalBlockCount(),
    paragraphCount: getGlobalBlockCount('core/paragraph')
  };
}), (0, _data.withDispatch)(dispatch => {
  const {
    editPost,
    resetEditorBlocks
  } = dispatch(_editor.store);
  const {
    updateSettings,
    clearSelectedBlock,
    insertBlock,
    replaceBlock
  } = dispatch(_blockEditor.store);
  const {
    switchEditorMode
  } = dispatch(_editPost.store);
  const {
    addEntities,
    receiveEntityRecords
  } = dispatch(_coreData.store);
  const {
    createSuccessNotice
  } = dispatch(_notices.store);
  return {
    updateSettings,
    addEntities,
    clearSelectedBlock,
    insertBlock,
    createSuccessNotice,

    editTitle(title) {
      editPost({
        title
      });
    },

    receiveEntityRecords,

    resetEditorBlocksWithoutUndoLevel(blocks) {
      resetEditorBlocks(blocks, {
        __unstableShouldCreateUndoLevel: false
      });
    },

    switchMode(mode) {
      switchEditorMode(mode);
    },

    replaceBlock
  };
})])(NativeEditorProvider);

exports.default = _default;
//# sourceMappingURL=index.native.js.map