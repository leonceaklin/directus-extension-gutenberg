"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = StartPageOptions;

var _element = require("@wordpress/element");

var _components = require("@wordpress/components");

var _i18n = require("@wordpress/i18n");

var _blockEditor = require("@wordpress/block-editor");

var _data = require("@wordpress/data");

var _compose = require("@wordpress/compose");

var _editor = require("@wordpress/editor");

var _store = require("../../store");

/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */
function useStartPatterns() {
  // A pattern is a start pattern if it includes 'core/post-content' in its blockTypes,
  // and it has no postTypes declares and the current post type is page or if
  // the current post type is part of the postTypes declared.
  const {
    blockPatternsWithPostContentBlockType,
    postType
  } = (0, _data.useSelect)(select => {
    const {
      __experimentalGetPatternsByBlockTypes
    } = select(_blockEditor.store);
    const {
      getCurrentPostType
    } = select(_editor.store);
    return {
      // get pa
      blockPatternsWithPostContentBlockType: __experimentalGetPatternsByBlockTypes('core/post-content'),
      postType: getCurrentPostType()
    };
  }, []);
  return (0, _element.useMemo)(() => {
    // filter patterns without postTypes declared if the current postType is page
    // or patterns that declare the current postType in its post type array.
    return blockPatternsWithPostContentBlockType.filter(pattern => {
      return postType === 'page' && !pattern.postTypes || Array.isArray(pattern.postTypes) && pattern.postTypes.includes(postType);
    });
  }, [postType, blockPatternsWithPostContentBlockType]);
}

function PatternSelection(_ref) {
  let {
    onChoosePattern
  } = _ref;
  const blockPatterns = useStartPatterns();
  const shownBlockPatterns = (0, _compose.useAsyncList)(blockPatterns);
  const {
    resetEditorBlocks
  } = (0, _data.useDispatch)(_editor.store);
  return (0, _element.createElement)(_blockEditor.__experimentalBlockPatternsList, {
    blockPatterns: blockPatterns,
    shownPatterns: shownBlockPatterns,
    onClickPattern: (_pattern, blocks) => {
      resetEditorBlocks(blocks);
      onChoosePattern();
    }
  });
}

const START_PAGE_MODAL_STATES = {
  INITIAL: 'INITIAL',
  PATTERN: 'PATTERN',
  CLOSED: 'CLOSED'
};

function StartPageOptions() {
  const [modalState, setModalState] = (0, _element.useState)(START_PAGE_MODAL_STATES.INITIAL);
  const blockPatterns = useStartPatterns();
  const hasStartPattern = blockPatterns.length > 0;
  const shouldOpenModel = (0, _data.useSelect)(select => {
    if (!hasStartPattern || modalState !== START_PAGE_MODAL_STATES.INITIAL) {
      return false;
    }

    const {
      getEditedPostContent,
      isEditedPostSaveable
    } = select(_editor.store);
    const {
      isEditingTemplate,
      isFeatureActive
    } = select(_store.store);
    return !isEditedPostSaveable() && '' === getEditedPostContent() && !isEditingTemplate() && !isFeatureActive('welcomeGuide');
  }, [modalState, hasStartPattern]);
  (0, _element.useEffect)(() => {
    if (shouldOpenModel) {
      setModalState(START_PAGE_MODAL_STATES.PATTERN);
    }
  }, [shouldOpenModel]);

  if (modalState === START_PAGE_MODAL_STATES.INITIAL || modalState === START_PAGE_MODAL_STATES.CLOSED) {
    return null;
  }

  return (0, _element.createElement)(_components.Modal, {
    className: "edit-post-start-page-options__modal",
    title: (0, _i18n.__)('Choose a pattern'),
    closeLabel: (0, _i18n.__)('Cancel'),
    onRequestClose: () => {
      setModalState(START_PAGE_MODAL_STATES.CLOSED);
    }
  }, (0, _element.createElement)("div", {
    className: "edit-post-start-page-options__modal-content"
  }, modalState === START_PAGE_MODAL_STATES.PATTERN && (0, _element.createElement)(PatternSelection, {
    onChoosePattern: () => {
      setModalState(START_PAGE_MODAL_STATES.CLOSED);
    }
  })));
}
//# sourceMappingURL=index.js.map