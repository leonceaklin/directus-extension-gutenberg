"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.__experimentalSetPreviewDeviceType = __experimentalSetPreviewDeviceType;
exports.closeGeneralSidebar = exports.__unstableSwitchToTemplateMode = exports.__unstableCreateTemplate = void 0;
exports.closeModal = closeModal;
exports.closePublishSidebar = closePublishSidebar;
exports.initializeMetaBoxes = exports.hideBlockTypes = void 0;
exports.metaBoxUpdatesFailure = metaBoxUpdatesFailure;
exports.metaBoxUpdatesSuccess = metaBoxUpdatesSuccess;
exports.openGeneralSidebar = void 0;
exports.openModal = openModal;
exports.openPublishSidebar = openPublishSidebar;
exports.removeEditorPanel = removeEditorPanel;
exports.requestMetaBoxUpdates = void 0;
exports.setAvailableMetaBoxesPerLocation = setAvailableMetaBoxesPerLocation;
exports.setIsEditingTemplate = setIsEditingTemplate;
exports.setIsInserterOpened = setIsInserterOpened;
exports.setIsListViewOpened = setIsListViewOpened;
exports.togglePinnedPluginItem = exports.toggleFeature = exports.toggleEditorPanelOpened = exports.toggleEditorPanelEnabled = exports.switchEditorMode = exports.showBlockTypes = void 0;
exports.togglePublishSidebar = togglePublishSidebar;
exports.updatePreferredStyleVariations = void 0;

var _i18n = require("@wordpress/i18n");

var _apiFetch = _interopRequireDefault(require("@wordpress/api-fetch"));

var _interface = require("@wordpress/interface");

var _preferences = require("@wordpress/preferences");

var _a11y = require("@wordpress/a11y");

var _notices = require("@wordpress/notices");

var _coreData = require("@wordpress/core-data");

var _blockEditor = require("@wordpress/block-editor");

var _editor = require("@wordpress/editor");

var _metaBoxes = require("../utils/meta-boxes");

var _ = require(".");

/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */

/**
 * Returns an action object used in signalling that the user opened an editor sidebar.
 *
 * @param {?string} name Sidebar name to be opened.
 */
const openGeneralSidebar = name => _ref => {
  let {
    registry
  } = _ref;
  return registry.dispatch(_interface.store).enableComplementaryArea(_.store.name, name);
};
/**
 * Returns an action object signalling that the user closed the sidebar.
 */


exports.openGeneralSidebar = openGeneralSidebar;

const closeGeneralSidebar = () => _ref2 => {
  let {
    registry
  } = _ref2;
  return registry.dispatch(_interface.store).disableComplementaryArea(_.store.name);
};
/**
 * Returns an action object used in signalling that the user opened a modal.
 *
 * @param {string} name A string that uniquely identifies the modal.
 *
 * @return {Object} Action object.
 */


exports.closeGeneralSidebar = closeGeneralSidebar;

function openModal(name) {
  return {
    type: 'OPEN_MODAL',
    name
  };
}
/**
 * Returns an action object signalling that the user closed a modal.
 *
 * @return {Object} Action object.
 */


function closeModal() {
  return {
    type: 'CLOSE_MODAL'
  };
}
/**
 * Returns an action object used in signalling that the user opened the publish
 * sidebar.
 *
 * @return {Object} Action object
 */


function openPublishSidebar() {
  return {
    type: 'OPEN_PUBLISH_SIDEBAR'
  };
}
/**
 * Returns an action object used in signalling that the user closed the
 * publish sidebar.
 *
 * @return {Object} Action object.
 */


function closePublishSidebar() {
  return {
    type: 'CLOSE_PUBLISH_SIDEBAR'
  };
}
/**
 * Returns an action object used in signalling that the user toggles the publish sidebar.
 *
 * @return {Object} Action object
 */


function togglePublishSidebar() {
  return {
    type: 'TOGGLE_PUBLISH_SIDEBAR'
  };
}
/**
 * Returns an action object used to enable or disable a panel in the editor.
 *
 * @param {string} panelName A string that identifies the panel to enable or disable.
 *
 * @return {Object} Action object.
 */


const toggleEditorPanelEnabled = panelName => _ref3 => {
  var _registry$select$get;

  let {
    registry
  } = _ref3;
  const inactivePanels = (_registry$select$get = registry.select(_preferences.store).get('core/edit-post', 'inactivePanels')) !== null && _registry$select$get !== void 0 ? _registry$select$get : [];
  const isPanelInactive = !!(inactivePanels !== null && inactivePanels !== void 0 && inactivePanels.includes(panelName)); // If the panel is inactive, remove it to enable it, else add it to
  // make it inactive.

  let updatedInactivePanels;

  if (isPanelInactive) {
    updatedInactivePanels = inactivePanels.filter(invactivePanelName => invactivePanelName !== panelName);
  } else {
    updatedInactivePanels = [...inactivePanels, panelName];
  }

  registry.dispatch(_preferences.store).set('core/edit-post', 'inactivePanels', updatedInactivePanels);
};
/**
 * Opens a closed panel and closes an open panel.
 *
 * @param {string} panelName A string that identifies the panel to open or close.
 */


exports.toggleEditorPanelEnabled = toggleEditorPanelEnabled;

const toggleEditorPanelOpened = panelName => _ref4 => {
  var _registry$select$get2;

  let {
    registry
  } = _ref4;
  const openPanels = (_registry$select$get2 = registry.select(_preferences.store).get('core/edit-post', 'openPanels')) !== null && _registry$select$get2 !== void 0 ? _registry$select$get2 : [];
  const isPanelOpen = !!(openPanels !== null && openPanels !== void 0 && openPanels.includes(panelName)); // If the panel is open, remove it to close it, else add it to
  // make it open.

  let updatedOpenPanels;

  if (isPanelOpen) {
    updatedOpenPanels = openPanels.filter(openPanelName => openPanelName !== panelName);
  } else {
    updatedOpenPanels = [...openPanels, panelName];
  }

  registry.dispatch(_preferences.store).set('core/edit-post', 'openPanels', updatedOpenPanels);
};
/**
 * Returns an action object used to remove a panel from the editor.
 *
 * @param {string} panelName A string that identifies the panel to remove.
 *
 * @return {Object} Action object.
 */


exports.toggleEditorPanelOpened = toggleEditorPanelOpened;

function removeEditorPanel(panelName) {
  return {
    type: 'REMOVE_PANEL',
    panelName
  };
}
/**
 * Triggers an action used to toggle a feature flag.
 *
 * @param {string} feature Feature name.
 */


const toggleFeature = feature => _ref5 => {
  let {
    registry
  } = _ref5;
  return registry.dispatch(_preferences.store).toggle('core/edit-post', feature);
};
/**
 * Triggers an action used to switch editor mode.
 *
 * @param {string} mode The editor mode.
 */


exports.toggleFeature = toggleFeature;

const switchEditorMode = mode => _ref6 => {
  let {
    registry
  } = _ref6;
  registry.dispatch(_preferences.store).set('core/edit-post', 'editorMode', mode); // Unselect blocks when we switch to the code editor.

  if (mode !== 'visual') {
    registry.dispatch(_blockEditor.store).clearSelectedBlock();
  }

  const message = mode === 'visual' ? (0, _i18n.__)('Visual editor selected') : (0, _i18n.__)('Code editor selected');
  (0, _a11y.speak)(message, 'assertive');
};
/**
 * Triggers an action object used to toggle a plugin name flag.
 *
 * @param {string} pluginName Plugin name.
 */


exports.switchEditorMode = switchEditorMode;

const togglePinnedPluginItem = pluginName => _ref7 => {
  let {
    registry
  } = _ref7;
  const isPinned = registry.select(_interface.store).isItemPinned('core/edit-post', pluginName);
  registry.dispatch(_interface.store)[isPinned ? 'unpinItem' : 'pinItem']('core/edit-post', pluginName);
};
/**
 * Returns an action object used in signaling that a style should be auto-applied when a block is created.
 *
 * @param {string}  blockName  Name of the block.
 * @param {?string} blockStyle Name of the style that should be auto applied. If undefined, the "auto apply" setting of the block is removed.
 */


exports.togglePinnedPluginItem = togglePinnedPluginItem;

const updatePreferredStyleVariations = (blockName, blockStyle) => _ref8 => {
  var _registry$select$get3;

  let {
    registry
  } = _ref8;

  if (!blockName) {
    return;
  }

  const existingVariations = (_registry$select$get3 = registry.select(_preferences.store).get('core/edit-post', 'preferredStyleVariations')) !== null && _registry$select$get3 !== void 0 ? _registry$select$get3 : {}; // When the blockStyle is omitted, remove the block's preferred variation.

  if (!blockStyle) {
    const updatedVariations = { ...existingVariations
    };
    delete updatedVariations[blockName];
    registry.dispatch(_preferences.store).set('core/edit-post', 'preferredStyleVariations', updatedVariations);
  } else {
    // Else add the variation.
    registry.dispatch(_preferences.store).set('core/edit-post', 'preferredStyleVariations', { ...existingVariations,
      [blockName]: blockStyle
    });
  }
};
/**
 * Update the provided block types to be visible.
 *
 * @param {string[]} blockNames Names of block types to show.
 */


exports.updatePreferredStyleVariations = updatePreferredStyleVariations;

const showBlockTypes = blockNames => _ref9 => {
  var _registry$select$get4;

  let {
    registry
  } = _ref9;
  const existingBlockNames = (_registry$select$get4 = registry.select(_preferences.store).get('core/edit-post', 'hiddenBlockTypes')) !== null && _registry$select$get4 !== void 0 ? _registry$select$get4 : [];
  const newBlockNames = existingBlockNames.filter(type => !(Array.isArray(blockNames) ? blockNames : [blockNames]).includes(type));
  registry.dispatch(_preferences.store).set('core/edit-post', 'hiddenBlockTypes', newBlockNames);
};
/**
 * Update the provided block types to be hidden.
 *
 * @param {string[]} blockNames Names of block types to hide.
 */


exports.showBlockTypes = showBlockTypes;

const hideBlockTypes = blockNames => _ref10 => {
  var _registry$select$get5;

  let {
    registry
  } = _ref10;
  const existingBlockNames = (_registry$select$get5 = registry.select(_preferences.store).get('core/edit-post', 'hiddenBlockTypes')) !== null && _registry$select$get5 !== void 0 ? _registry$select$get5 : [];
  const mergedBlockNames = new Set([...existingBlockNames, ...(Array.isArray(blockNames) ? blockNames : [blockNames])]);
  registry.dispatch(_preferences.store).set('core/edit-post', 'hiddenBlockTypes', [...mergedBlockNames]);
};
/**
 * Stores info about which Meta boxes are available in which location.
 *
 * @param {Object} metaBoxesPerLocation Meta boxes per location.
 */


exports.hideBlockTypes = hideBlockTypes;

function setAvailableMetaBoxesPerLocation(metaBoxesPerLocation) {
  return {
    type: 'SET_META_BOXES_PER_LOCATIONS',
    metaBoxesPerLocation
  };
}
/**
 * Update a metabox.
 */


const requestMetaBoxUpdates = () => async _ref11 => {
  let {
    registry,
    select,
    dispatch
  } = _ref11;
  dispatch({
    type: 'REQUEST_META_BOX_UPDATES'
  }); // Saves the wp_editor fields.

  if (window.tinyMCE) {
    window.tinyMCE.triggerSave();
  } // Additional data needed for backward compatibility.
  // If we do not provide this data, the post will be overridden with the default values.


  const post = registry.select(_editor.store).getCurrentPost();
  const additionalData = [post.comment_status ? ['comment_status', post.comment_status] : false, post.ping_status ? ['ping_status', post.ping_status] : false, post.sticky ? ['sticky', post.sticky] : false, post.author ? ['post_author', post.author] : false].filter(Boolean); // We gather all the metaboxes locations data and the base form data.

  const baseFormData = new window.FormData(document.querySelector('.metabox-base-form'));
  const activeMetaBoxLocations = select.getActiveMetaBoxLocations();
  const formDataToMerge = [baseFormData, ...activeMetaBoxLocations.map(location => new window.FormData((0, _metaBoxes.getMetaBoxContainer)(location)))]; // Merge all form data objects into a single one.

  const formData = formDataToMerge.reduce((memo, currentFormData) => {
    for (const [key, value] of currentFormData) {
      memo.append(key, value);
    }

    return memo;
  }, new window.FormData());
  additionalData.forEach(_ref12 => {
    let [key, value] = _ref12;
    return formData.append(key, value);
  });

  try {
    // Save the metaboxes.
    await (0, _apiFetch.default)({
      url: window._wpMetaBoxUrl,
      method: 'POST',
      body: formData,
      parse: false
    });
    dispatch.metaBoxUpdatesSuccess();
  } catch {
    dispatch.metaBoxUpdatesFailure();
  }
};
/**
 * Returns an action object used to signal a successful meta box update.
 *
 * @return {Object} Action object.
 */


exports.requestMetaBoxUpdates = requestMetaBoxUpdates;

function metaBoxUpdatesSuccess() {
  return {
    type: 'META_BOX_UPDATES_SUCCESS'
  };
}
/**
 * Returns an action object used to signal a failed meta box update.
 *
 * @return {Object} Action object.
 */


function metaBoxUpdatesFailure() {
  return {
    type: 'META_BOX_UPDATES_FAILURE'
  };
}
/**
 * Returns an action object used to toggle the width of the editing canvas.
 *
 * @param {string} deviceType
 *
 * @return {Object} Action object.
 */


function __experimentalSetPreviewDeviceType(deviceType) {
  return {
    type: 'SET_PREVIEW_DEVICE_TYPE',
    deviceType
  };
}
/**
 * Returns an action object used to open/close the inserter.
 *
 * @param {boolean|Object} value                Whether the inserter should be
 *                                              opened (true) or closed (false).
 *                                              To specify an insertion point,
 *                                              use an object.
 * @param {string}         value.rootClientId   The root client ID to insert at.
 * @param {number}         value.insertionIndex The index to insert at.
 *
 * @return {Object} Action object.
 */


function setIsInserterOpened(value) {
  return {
    type: 'SET_IS_INSERTER_OPENED',
    value
  };
}
/**
 * Returns an action object used to open/close the list view.
 *
 * @param {boolean} isOpen A boolean representing whether the list view should be opened or closed.
 * @return {Object} Action object.
 */


function setIsListViewOpened(isOpen) {
  return {
    type: 'SET_IS_LIST_VIEW_OPENED',
    isOpen
  };
}
/**
 * Returns an action object used to switch to template editing.
 *
 * @param {boolean} value Is editing template.
 * @return {Object} Action object.
 */


function setIsEditingTemplate(value) {
  return {
    type: 'SET_IS_EDITING_TEMPLATE',
    value
  };
}
/**
 * Switches to the template mode.
 *
 * @param {boolean} newTemplate Is new template.
 */


const __unstableSwitchToTemplateMode = function () {
  let newTemplate = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
  return _ref13 => {
    let {
      registry,
      select,
      dispatch
    } = _ref13;
    dispatch(setIsEditingTemplate(true));
    const isWelcomeGuideActive = select.isFeatureActive('welcomeGuideTemplate');

    if (!isWelcomeGuideActive) {
      const message = newTemplate ? (0, _i18n.__)("Custom template created. You're in template mode now.") : (0, _i18n.__)('Editing template. Changes made here affect all posts and pages that use the template.');
      registry.dispatch(_notices.store).createSuccessNotice(message, {
        type: 'snackbar'
      });
    }
  };
};
/**
 * Create a block based template.
 *
 * @param {Object?} template Template to create and assign.
 */


exports.__unstableSwitchToTemplateMode = __unstableSwitchToTemplateMode;

const __unstableCreateTemplate = template => async _ref14 => {
  let {
    registry
  } = _ref14;
  const savedTemplate = await registry.dispatch(_coreData.store).saveEntityRecord('postType', 'wp_template', template);
  const post = registry.select(_editor.store).getCurrentPost();
  registry.dispatch(_coreData.store).editEntityRecord('postType', post.type, post.id, {
    template: savedTemplate.slug
  });
};

exports.__unstableCreateTemplate = __unstableCreateTemplate;
let metaBoxesInitialized = false;
/**
 * Initializes WordPress `postboxes` script and the logic for saving meta boxes.
 */

const initializeMetaBoxes = () => _ref15 => {
  let {
    registry,
    select,
    dispatch
  } = _ref15;

  const isEditorReady = registry.select(_editor.store).__unstableIsEditorReady();

  if (!isEditorReady) {
    return;
  } // Only initialize once.


  if (metaBoxesInitialized) {
    return;
  }

  const postType = registry.select(_editor.store).getCurrentPostType();

  if (window.postboxes.page !== postType) {
    window.postboxes.add_postbox_toggles(postType);
  }

  metaBoxesInitialized = true;
  let wasSavingPost = registry.select(_editor.store).isSavingPost();
  let wasAutosavingPost = registry.select(_editor.store).isAutosavingPost(); // Save metaboxes when performing a full save on the post.

  registry.subscribe(async () => {
    const isSavingPost = registry.select(_editor.store).isSavingPost();
    const isAutosavingPost = registry.select(_editor.store).isAutosavingPost(); // Save metaboxes on save completion, except for autosaves.

    const shouldTriggerMetaboxesSave = wasSavingPost && !wasAutosavingPost && !isSavingPost && select.hasMetaBoxes(); // Save current state for next inspection.

    wasSavingPost = isSavingPost;
    wasAutosavingPost = isAutosavingPost;

    if (shouldTriggerMetaboxesSave) {
      await dispatch.requestMetaBoxUpdates();
    }
  });
  dispatch({
    type: 'META_BOXES_INITIALIZED'
  });
};

exports.initializeMetaBoxes = initializeMetaBoxes;
//# sourceMappingURL=actions.js.map