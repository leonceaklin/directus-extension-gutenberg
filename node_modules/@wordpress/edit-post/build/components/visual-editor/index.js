"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = VisualEditor;

var _element = require("@wordpress/element");

var _classnames = _interopRequireDefault(require("classnames"));

var _editor = require("@wordpress/editor");

var _blockEditor = require("@wordpress/block-editor");

var _components = require("@wordpress/components");

var _data = require("@wordpress/data");

var _compose = require("@wordpress/compose");

var _icons = require("@wordpress/icons");

var _i18n = require("@wordpress/i18n");

var _blocks = require("@wordpress/blocks");

var _coreData = require("@wordpress/core-data");

var _blockInspectorButton = _interopRequireDefault(require("./block-inspector-button"));

var _store = require("../../store");

/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */
function MaybeIframe(_ref) {
  let {
    children,
    contentRef,
    shouldIframe,
    styles,
    assets,
    style
  } = _ref;
  const ref = (0, _blockEditor.__unstableUseMouseMoveTypingReset)();

  if (!shouldIframe) {
    return (0, _element.createElement)(_element.Fragment, null, (0, _element.createElement)(_blockEditor.__unstableEditorStyles, {
      styles: styles
    }), (0, _element.createElement)(_blockEditor.WritingFlow, {
      ref: contentRef,
      className: "editor-styles-wrapper",
      style: {
        flex: '1',
        ...style
      },
      tabIndex: -1
    }, children));
  }

  return (0, _element.createElement)(_blockEditor.__unstableIframe, {
    head: (0, _element.createElement)(_blockEditor.__unstableEditorStyles, {
      styles: styles
    }),
    assets: assets,
    ref: ref,
    contentRef: contentRef,
    style: {
      width: '100%',
      height: '100%',
      display: 'block'
    },
    name: "editor-canvas"
  }, children);
}
/**
 * Given an array of nested blocks, find the first Post Content
 * block inside it, recursing through any nesting levels.
 *
 * @param {Array} blocks A list of blocks.
 *
 * @return {Object} The Post Content block.
 */


function findPostContent(blocks) {
  for (let i = 0; i < blocks.length; i++) {
    if (blocks[i].name === 'core/post-content') {
      return blocks[i];
    }

    if (blocks[i].innerBlocks.length) {
      const nestedPostContent = findPostContent(blocks[i].innerBlocks);

      if (nestedPostContent) {
        return nestedPostContent;
      }
    }
  }
}

function VisualEditor(_ref2) {
  var _postContentBlock$att;

  let {
    styles
  } = _ref2;
  const {
    deviceType,
    isWelcomeGuideVisible,
    isTemplateMode,
    editedPostTemplate = {},
    wrapperBlockName,
    wrapperUniqueId,
    isBlockBasedTheme
  } = (0, _data.useSelect)(select => {
    const {
      isFeatureActive,
      isEditingTemplate,
      __experimentalGetPreviewDeviceType,
      getEditedPostTemplate
    } = select(_store.store);
    const {
      getCurrentPostId,
      getCurrentPostType,
      getEditorSettings
    } = select(_editor.store);

    const _isTemplateMode = isEditingTemplate();

    let _wrapperBlockName;

    if (getCurrentPostType() === 'wp_block') {
      _wrapperBlockName = 'core/block';
    } else if (!_isTemplateMode) {
      _wrapperBlockName = 'core/post-content';
    }

    const editorSettings = getEditorSettings();
    const supportsTemplateMode = editorSettings.supportsTemplateMode;
    const canEditTemplate = select(_coreData.store).canUser('create', 'templates');
    return {
      deviceType: __experimentalGetPreviewDeviceType(),
      isWelcomeGuideVisible: isFeatureActive('welcomeGuide'),
      isTemplateMode: _isTemplateMode,
      // Post template fetch returns a 404 on classic themes, which
      // messes with e2e tests, so we check it's a block theme first.
      editedPostTemplate: supportsTemplateMode && canEditTemplate ? getEditedPostTemplate() : undefined,
      wrapperBlockName: _wrapperBlockName,
      wrapperUniqueId: getCurrentPostId(),
      isBlockBasedTheme: editorSettings.__unstableIsBlockBasedTheme
    };
  }, []);
  const {
    isCleanNewPost
  } = (0, _data.useSelect)(_editor.store);
  const hasMetaBoxes = (0, _data.useSelect)(select => select(_store.store).hasMetaBoxes(), []);
  const {
    themeHasDisabledLayoutStyles,
    themeSupportsLayout,
    assets,
    isFocusMode
  } = (0, _data.useSelect)(select => {
    const _settings = select(_blockEditor.store).getSettings();

    return {
      themeHasDisabledLayoutStyles: _settings.disableLayoutStyles,
      themeSupportsLayout: _settings.supportsLayout,
      assets: _settings.__unstableResolvedAssets,
      isFocusMode: _settings.focusMode
    };
  }, []);
  const {
    clearSelectedBlock
  } = (0, _data.useDispatch)(_blockEditor.store);
  const {
    setIsEditingTemplate
  } = (0, _data.useDispatch)(_store.store);
  const desktopCanvasStyles = {
    height: '100%',
    width: '100%',
    margin: 0,
    display: 'flex',
    flexFlow: 'column',
    // Default background color so that grey
    // .edit-post-editor-regions__content color doesn't show through.
    background: 'white'
  };
  const templateModeStyles = { ...desktopCanvasStyles,
    borderRadius: '2px 2px 0 0',
    border: '1px solid #ddd',
    borderBottom: 0
  };
  const resizedCanvasStyles = (0, _blockEditor.__experimentalUseResizeCanvas)(deviceType, isTemplateMode);
  const globalLayoutSettings = (0, _blockEditor.useSetting)('layout');
  const previewMode = 'is-' + deviceType.toLowerCase() + '-preview';
  let animatedStyles = isTemplateMode ? templateModeStyles : desktopCanvasStyles;

  if (resizedCanvasStyles) {
    animatedStyles = resizedCanvasStyles;
  }

  let paddingBottom; // Add a constant padding for the typewritter effect. When typing at the
  // bottom, there needs to be room to scroll up.

  if (!hasMetaBoxes && !resizedCanvasStyles && !isTemplateMode) {
    paddingBottom = '40vh';
  }

  const ref = (0, _element.useRef)();
  const contentRef = (0, _compose.useMergeRefs)([ref, (0, _blockEditor.__unstableUseClipboardHandler)(), (0, _blockEditor.__unstableUseTypewriter)(), (0, _blockEditor.__unstableUseTypingObserver)(), (0, _blockEditor.__unstableUseBlockSelectionClearer)()]);
  const blockSelectionClearerRef = (0, _blockEditor.__unstableUseBlockSelectionClearer)(); // fallbackLayout is used if there is no Post Content,
  // and for Post Title.

  const fallbackLayout = (0, _element.useMemo)(() => {
    if (isTemplateMode) {
      return {
        type: 'default'
      };
    }

    if (themeSupportsLayout) {
      // We need to ensure support for wide and full alignments,
      // so we add the constrained type.
      return { ...globalLayoutSettings,
        type: 'constrained'
      };
    } // Set default layout for classic themes so all alignments are supported.


    return {
      type: 'default'
    };
  }, [isTemplateMode, themeSupportsLayout, globalLayoutSettings]);
  const postContentBlock = (0, _element.useMemo)(() => {
    // When in template editing mode, we can access the blocks directly.
    if (editedPostTemplate !== null && editedPostTemplate !== void 0 && editedPostTemplate.blocks) {
      return findPostContent(editedPostTemplate === null || editedPostTemplate === void 0 ? void 0 : editedPostTemplate.blocks);
    } // If there are no blocks, we have to parse the content string.
    // Best double-check it's a string otherwise the parse function gets unhappy.


    const parseableContent = typeof (editedPostTemplate === null || editedPostTemplate === void 0 ? void 0 : editedPostTemplate.content) === 'string' ? editedPostTemplate === null || editedPostTemplate === void 0 ? void 0 : editedPostTemplate.content : '';
    return findPostContent((0, _blocks.parse)(parseableContent)) || {};
  }, [editedPostTemplate === null || editedPostTemplate === void 0 ? void 0 : editedPostTemplate.content, editedPostTemplate === null || editedPostTemplate === void 0 ? void 0 : editedPostTemplate.blocks]);
  const postContentLayoutClasses = (0, _blockEditor.__experimentaluseLayoutClasses)(postContentBlock);
  const blockListLayoutClass = (0, _classnames.default)({
    'is-layout-flow': !themeSupportsLayout
  }, themeSupportsLayout && postContentLayoutClasses);
  const postContentLayoutStyles = (0, _blockEditor.__experimentaluseLayoutStyles)(postContentBlock, '.block-editor-block-list__layout.is-root-container');
  const layout = (postContentBlock === null || postContentBlock === void 0 ? void 0 : (_postContentBlock$att = postContentBlock.attributes) === null || _postContentBlock$att === void 0 ? void 0 : _postContentBlock$att.layout) || {}; // Update type for blocks using legacy layouts.

  const postContentLayout = (0, _element.useMemo)(() => {
    return layout && ((layout === null || layout === void 0 ? void 0 : layout.type) === 'constrained' || layout !== null && layout !== void 0 && layout.inherit || layout !== null && layout !== void 0 && layout.contentSize || layout !== null && layout !== void 0 && layout.wideSize) ? { ...globalLayoutSettings,
      ...layout,
      type: 'constrained'
    } : { ...globalLayoutSettings,
      ...layout,
      type: 'default'
    };
  }, [layout === null || layout === void 0 ? void 0 : layout.type, layout === null || layout === void 0 ? void 0 : layout.inherit, layout === null || layout === void 0 ? void 0 : layout.contentSize, layout === null || layout === void 0 ? void 0 : layout.wideSize, globalLayoutSettings]); // If there is a Post Content block we use its layout for the block list;
  // if not, this must be a classic theme, in which case we use the fallback layout.

  const blockListLayout = postContentBlock ? postContentLayout : fallbackLayout;
  const titleRef = (0, _element.useRef)();
  (0, _element.useEffect)(() => {
    var _titleRef$current;

    if (isWelcomeGuideVisible || !isCleanNewPost()) {
      return;
    }

    titleRef === null || titleRef === void 0 ? void 0 : (_titleRef$current = titleRef.current) === null || _titleRef$current === void 0 ? void 0 : _titleRef$current.focus();
  }, [isWelcomeGuideVisible, isCleanNewPost]);
  styles = (0, _element.useMemo)(() => [...styles, {
    // We should move this in to future to the body.
    css: `.edit-post-visual-editor__post-title-wrapper{margin-top:4rem}` + (paddingBottom ? `body{padding-bottom:${paddingBottom}}` : '')
  }], [styles]);
  return (0, _element.createElement)(_blockEditor.BlockTools, {
    __unstableContentRef: ref,
    className: (0, _classnames.default)('edit-post-visual-editor', {
      'is-template-mode': isTemplateMode
    })
  }, (0, _element.createElement)(_editor.VisualEditorGlobalKeyboardShortcuts, null), (0, _element.createElement)(_components.__unstableMotion.div, {
    className: "edit-post-visual-editor__content-area",
    animate: {
      padding: isTemplateMode ? '48px 48px 0' : '0'
    },
    ref: blockSelectionClearerRef
  }, isTemplateMode && (0, _element.createElement)(_components.Button, {
    className: "edit-post-visual-editor__exit-template-mode",
    icon: _icons.arrowLeft,
    onClick: () => {
      clearSelectedBlock();
      setIsEditingTemplate(false);
    }
  }, (0, _i18n.__)('Back')), (0, _element.createElement)(_components.__unstableMotion.div, {
    animate: animatedStyles,
    initial: desktopCanvasStyles,
    className: previewMode
  }, (0, _element.createElement)(MaybeIframe, {
    shouldIframe: isBlockBasedTheme && !hasMetaBoxes || isTemplateMode || deviceType === 'Tablet' || deviceType === 'Mobile',
    contentRef: contentRef,
    styles: styles,
    assets: assets
  }, themeSupportsLayout && !themeHasDisabledLayoutStyles && !isTemplateMode && (0, _element.createElement)(_element.Fragment, null, (0, _element.createElement)(_blockEditor.__experimentalLayoutStyle, {
    selector: ".edit-post-visual-editor__post-title-wrapper, .block-editor-block-list__layout.is-root-container",
    layout: fallbackLayout,
    layoutDefinitions: globalLayoutSettings === null || globalLayoutSettings === void 0 ? void 0 : globalLayoutSettings.definitions
  }), postContentLayoutStyles && (0, _element.createElement)(_blockEditor.__experimentalLayoutStyle, {
    layout: postContentLayout,
    css: postContentLayoutStyles,
    layoutDefinitions: globalLayoutSettings === null || globalLayoutSettings === void 0 ? void 0 : globalLayoutSettings.definitions
  })), !isTemplateMode && (0, _element.createElement)("div", {
    className: (0, _classnames.default)( // This wrapper div should have the same
    // classes as the block list beneath.
    'is-root-container', 'block-editor-block-list__layout', 'edit-post-visual-editor__post-title-wrapper', {
      'is-focus-mode': isFocusMode
    }, blockListLayoutClass),
    contentEditable: false
  }, (0, _element.createElement)(_editor.PostTitle, {
    ref: titleRef
  })), (0, _element.createElement)(_blockEditor.__experimentalRecursionProvider, {
    blockName: wrapperBlockName,
    uniqueId: wrapperUniqueId
  }, (0, _element.createElement)(_blockEditor.BlockList, {
    className: isTemplateMode ? 'wp-site-blocks' : `${blockListLayoutClass} wp-block-post-content` // Ensure root level blocks receive default/flow blockGap styling rules.
    ,
    __experimentalLayout: blockListLayout
  }))))), (0, _element.createElement)(_blockEditor.__unstableBlockSettingsMenuFirstItem, null, _ref3 => {
    let {
      onClose
    } = _ref3;
    return (0, _element.createElement)(_blockInspectorButton.default, {
      onClick: onClose
    });
  }));
}
//# sourceMappingURL=index.js.map