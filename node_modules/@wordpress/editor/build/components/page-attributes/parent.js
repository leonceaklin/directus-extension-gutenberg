"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PageAttributesParent = PageAttributesParent;
exports.getItemPriority = exports.default = void 0;

var _element = require("@wordpress/element");

var _lodash = require("lodash");

var _removeAccents = _interopRequireDefault(require("remove-accents"));

var _i18n = require("@wordpress/i18n");

var _components = require("@wordpress/components");

var _compose = require("@wordpress/compose");

var _data = require("@wordpress/data");

var _htmlEntities = require("@wordpress/html-entities");

var _coreData = require("@wordpress/core-data");

var _terms = require("../../utils/terms");

var _store = require("../../store");

/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */
function getTitle(post) {
  var _post$title;

  return post !== null && post !== void 0 && (_post$title = post.title) !== null && _post$title !== void 0 && _post$title.rendered ? (0, _htmlEntities.decodeEntities)(post.title.rendered) : `#${post.id} (${(0, _i18n.__)('no title')})`;
}

const getItemPriority = (name, searchValue) => {
  const normalizedName = (0, _removeAccents.default)(name || '').toLowerCase();
  const normalizedSearch = (0, _removeAccents.default)(searchValue || '').toLowerCase();

  if (normalizedName === normalizedSearch) {
    return 0;
  }

  if (normalizedName.startsWith(normalizedSearch)) {
    return normalizedName.length;
  }

  return Infinity;
};

exports.getItemPriority = getItemPriority;

function PageAttributesParent() {
  const {
    editPost
  } = (0, _data.useDispatch)(_store.store);
  const [fieldValue, setFieldValue] = (0, _element.useState)(false);
  const {
    parentPost,
    parentPostId,
    items,
    postType
  } = (0, _data.useSelect)(select => {
    const {
      getPostType,
      getEntityRecords,
      getEntityRecord
    } = select(_coreData.store);
    const {
      getCurrentPostId,
      getEditedPostAttribute
    } = select(_store.store);
    const postTypeSlug = getEditedPostAttribute('type');
    const pageId = getEditedPostAttribute('parent');
    const pType = getPostType(postTypeSlug);
    const postId = getCurrentPostId();
    const isHierarchical = (0, _lodash.get)(pType, ['hierarchical'], false);
    const query = {
      per_page: 100,
      exclude: postId,
      parent_exclude: postId,
      orderby: 'menu_order',
      order: 'asc',
      _fields: 'id,title,parent'
    }; // Perform a search when the field is changed.

    if (!!fieldValue) {
      query.search = fieldValue;
    }

    return {
      parentPostId: pageId,
      parentPost: pageId ? getEntityRecord('postType', postTypeSlug, pageId) : null,
      items: isHierarchical ? getEntityRecords('postType', postTypeSlug, query) : [],
      postType: pType
    };
  }, [fieldValue]);
  const isHierarchical = (0, _lodash.get)(postType, ['hierarchical'], false);
  const parentPageLabel = (0, _lodash.get)(postType, ['labels', 'parent_item_colon']);
  const pageItems = items || [];
  const parentOptions = (0, _element.useMemo)(() => {
    const getOptionsFromTree = function (tree) {
      let level = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      const mappedNodes = tree.map(treeNode => [{
        value: treeNode.id,
        label: 'â€” '.repeat(level) + (0, _lodash.unescape)(treeNode.name),
        rawName: treeNode.name
      }, ...getOptionsFromTree(treeNode.children || [], level + 1)]);
      const sortedNodes = mappedNodes.sort((_ref, _ref2) => {
        let [a] = _ref;
        let [b] = _ref2;
        const priorityA = getItemPriority(a.rawName, fieldValue);
        const priorityB = getItemPriority(b.rawName, fieldValue);
        return priorityA >= priorityB ? 1 : -1;
      });
      return sortedNodes.flat();
    };

    let tree = pageItems.map(item => ({
      id: item.id,
      parent: item.parent,
      name: getTitle(item)
    })); // Only build a hierarchical tree when not searching.

    if (!fieldValue) {
      tree = (0, _terms.buildTermsTree)(tree);
    }

    const opts = getOptionsFromTree(tree); // Ensure the current parent is in the options list.

    const optsHasParent = opts.find(item => item.value === parentPostId);

    if (parentPost && !optsHasParent) {
      opts.unshift({
        value: parentPostId,
        label: getTitle(parentPost)
      });
    }

    return opts;
  }, [pageItems, fieldValue]);

  if (!isHierarchical || !parentPageLabel) {
    return null;
  }
  /**
   * Handle user input.
   *
   * @param {string} inputValue The current value of the input field.
   */


  const handleKeydown = inputValue => {
    setFieldValue(inputValue);
  };
  /**
   * Handle author selection.
   *
   * @param {Object} selectedPostId The selected Author.
   */


  const handleChange = selectedPostId => {
    editPost({
      parent: selectedPostId
    });
  };

  return (0, _element.createElement)(_components.ComboboxControl, {
    __nextHasNoMarginBottom: true,
    className: "editor-page-attributes__parent",
    label: parentPageLabel,
    value: parentPostId,
    options: parentOptions,
    onFilterValueChange: (0, _compose.debounce)(handleKeydown, 300),
    onChange: handleChange
  });
}

var _default = PageAttributesParent;
exports.default = _default;
//# sourceMappingURL=parent.js.map