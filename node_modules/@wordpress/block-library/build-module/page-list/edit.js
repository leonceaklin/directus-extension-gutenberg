import { createElement, Fragment } from "@wordpress/element";

/**
 * External dependencies
 */
import classnames from 'classnames';
/**
 * WordPress dependencies
 */

import { createBlock } from '@wordpress/blocks';
import { InspectorControls, BlockControls, useBlockProps, useInnerBlocksProps, getColorClassName, store as blockEditorStore, Warning } from '@wordpress/block-editor';
import { PanelBody, ToolbarButton, Spinner, Notice, ComboboxControl, Button } from '@wordpress/components';
import { __, sprintf } from '@wordpress/i18n';
import { useMemo, useState, useEffect } from '@wordpress/element';
import { useEntityRecords } from '@wordpress/core-data';
import { useSelect, useDispatch } from '@wordpress/data';
/**
 * Internal dependencies
 */

import ConvertToLinksModal from './convert-to-links-modal';
import { convertToNavigationLinks } from './convert-to-navigation-links';
import { convertDescription } from './constants'; // We only show the edit option when page count is <= MAX_PAGE_COUNT
// Performance of Navigation Links is not good past this value.

const MAX_PAGE_COUNT = 100;

const NOOP = () => {};

export default function PageListEdit(_ref) {
  var _context$style;

  let {
    context,
    clientId,
    attributes,
    setAttributes
  } = _ref;
  const {
    parentPageID
  } = attributes;
  const [pages] = useGetPages();
  const {
    pagesByParentId,
    totalPages,
    hasResolvedPages
  } = usePageData();
  const isNavigationChild = ('showSubmenuIcon' in context);
  const allowConvertToLinks = isNavigationChild && totalPages <= MAX_PAGE_COUNT;
  const [isOpen, setOpen] = useState(false);

  const openModal = () => setOpen(true);

  const closeModal = () => setOpen(false);

  const blockProps = useBlockProps({
    className: classnames('wp-block-page-list', {
      'has-text-color': !!context.textColor,
      [getColorClassName('color', context.textColor)]: !!context.textColor,
      'has-background': !!context.backgroundColor,
      [getColorClassName('background-color', context.backgroundColor)]: !!context.backgroundColor
    }),
    style: { ...((_context$style = context.style) === null || _context$style === void 0 ? void 0 : _context$style.color)
    }
  });

  const getBlockList = function () {
    let parentId = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : parentPageID;
    const childPages = pagesByParentId.get(parentId);

    if (!(childPages !== null && childPages !== void 0 && childPages.length)) {
      return [];
    }

    return childPages.reduce((template, page) => {
      var _page$title, _page$title2;

      const hasChildren = pagesByParentId.has(page.id);
      const pageProps = {
        id: page.id,
        label: (_page$title = page.title) === null || _page$title === void 0 ? void 0 : _page$title.rendered,
        title: (_page$title2 = page.title) === null || _page$title2 === void 0 ? void 0 : _page$title2.rendered,
        link: page.url,
        hasChildren
      };
      let item = null;
      const children = getBlockList(page.id);
      item = createBlock('core/page-list-item', pageProps, children);
      template.push(item);
      return template;
    }, []);
  };

  const makePagesTree = function () {
    let parentId = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    let level = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    const childPages = pagesByParentId.get(parentId);

    if (!(childPages !== null && childPages !== void 0 && childPages.length)) {
      return [];
    }

    return childPages.reduce((tree, page) => {
      const hasChildren = pagesByParentId.has(page.id);
      const item = {
        value: page.id,
        label: 'â€” '.repeat(level) + page.title.rendered,
        rawName: page.title.rendered
      };
      tree.push(item);

      if (hasChildren) {
        tree.push(...makePagesTree(page.id, level + 1));
      }

      return tree;
    }, []);
  };

  const pagesTree = useMemo(makePagesTree, [pagesByParentId]);
  const blockList = useMemo(getBlockList, [pagesByParentId, parentPageID]);
  const innerBlocksProps = useInnerBlocksProps(blockProps, {
    allowedBlocks: ['core/page-list-item'],
    renderAppender: false,
    __unstableDisableDropZone: true,
    templateLock: 'all',
    onInput: NOOP,
    onChange: NOOP,
    value: blockList
  });

  const getBlockContent = () => {
    if (!hasResolvedPages) {
      return createElement("div", blockProps, createElement(Spinner, null));
    }

    if (totalPages === null) {
      return createElement("div", blockProps, createElement(Notice, {
        status: 'warning',
        isDismissible: false
      }, __('Page List: Cannot retrieve Pages.')));
    }

    if (totalPages === 0) {
      return createElement("div", blockProps, createElement(Notice, {
        status: 'info',
        isDismissible: false
      }, __('Page List: Cannot retrieve Pages.')));
    }

    if (blockList.length === 0) {
      const parentPageDetails = pages && pages.find(page => page.id === parentPageID);
      return createElement("div", blockProps, createElement(Warning, null, sprintf( // translators: %s: Page title.
      __('"%s" page has no children.'), parentPageDetails.title.rendered)));
    }

    if (totalPages > 0) {
      return createElement("ul", innerBlocksProps);
    }
  };

  const {
    replaceBlock,
    selectBlock
  } = useDispatch(blockEditorStore);
  const {
    parentNavBlockClientId,
    isNested
  } = useSelect(select => {
    const {
      getSelectedBlockClientId,
      getBlockParentsByBlockName
    } = select(blockEditorStore);

    const _selectedBlockClientId = getSelectedBlockClientId();

    return {
      parentNavBlockClientId: getBlockParentsByBlockName(_selectedBlockClientId, 'core/navigation', true)[0],
      isNested: getBlockParentsByBlockName(clientId, 'core/navigation-submenu', true).length > 0
    };
  }, [clientId]);
  useEffect(() => {
    setAttributes({
      isNested
    });
  }, [isNested]);
  return createElement(Fragment, null, createElement(InspectorControls, null, isNavigationChild && (pages === null || pages === void 0 ? void 0 : pages.length) > 0 && createElement(PanelBody, {
    title: __('Customize this menu')
  }, createElement("p", null, convertDescription), createElement(Button, {
    variant: "primary",
    disabled: !hasResolvedPages,
    onClick: () => {
      const navigationLinks = convertToNavigationLinks(pages); // Replace the Page List block with the Navigation Links.

      replaceBlock(clientId, navigationLinks); // Select the Navigation block to reveal the changes.

      selectBlock(parentNavBlockClientId);
    }
  }, __('Customize'))), pagesTree.length > 0 && createElement(PanelBody, null, createElement(ComboboxControl, {
    className: "editor-page-attributes__parent",
    label: __('Parent page'),
    value: parentPageID,
    options: pagesTree,
    onChange: value => setAttributes({
      parentPageID: value !== null && value !== void 0 ? value : 0
    }),
    help: __('Choose a page to show only its subpages.')
  }))), allowConvertToLinks && totalPages > 0 && createElement(BlockControls, {
    group: "other"
  }, createElement(ToolbarButton, {
    title: __('Edit'),
    onClick: openModal
  }, __('Edit'))), allowConvertToLinks && isOpen && createElement(ConvertToLinksModal, {
    onClose: closeModal,
    clientId: clientId
  }), getBlockContent());
}

function useGetPages() {
  const {
    records: pages,
    hasResolved: hasResolvedPages
  } = useEntityRecords('postType', 'page', {
    orderby: 'menu_order',
    order: 'asc',
    _fields: ['id', 'link', 'parent', 'title', 'menu_order'],
    per_page: -1,
    context: 'view'
  });
  return [pages, hasResolvedPages];
}

function usePageData() {
  let pageId = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
  const [pages, hasResolvedPages] = useGetPages();
  return useMemo(() => {
    var _pages$length;

    // TODO: Once the REST API supports passing multiple values to
    // 'orderby', this can be removed.
    // https://core.trac.wordpress.org/ticket/39037
    const sortedPages = [...(pages !== null && pages !== void 0 ? pages : [])].sort((a, b) => {
      if (a.menu_order === b.menu_order) {
        return a.title.rendered.localeCompare(b.title.rendered);
      }

      return a.menu_order - b.menu_order;
    });
    const pagesByParentId = sortedPages.reduce((accumulator, page) => {
      const {
        parent
      } = page;

      if (accumulator.has(parent)) {
        accumulator.get(parent).push(page);
      } else {
        accumulator.set(parent, [page]);
      }

      return accumulator;
    }, new Map());
    return {
      pagesByParentId,
      hasResolvedPages,
      totalPages: (_pages$length = pages === null || pages === void 0 ? void 0 : pages.length) !== null && _pages$length !== void 0 ? _pages$length : null
    };
  }, [pageId, pages, hasResolvedPages]);
}
//# sourceMappingURL=edit.js.map