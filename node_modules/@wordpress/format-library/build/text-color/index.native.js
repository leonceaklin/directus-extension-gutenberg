"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.textColor = void 0;

var _element = require("@wordpress/element");

var _reactNative = require("react-native");

var _i18n = require("@wordpress/i18n");

var _blockEditor = require("@wordpress/block-editor");

var _components = require("@wordpress/components");

var _icons = require("@wordpress/icons");

var _richText = require("@wordpress/rich-text");

var _compose = require("@wordpress/compose");

var _inline = require("./inline.js");

var _index = require("./index.js");

var _inline2 = _interopRequireDefault(require("./inline"));

var _style = _interopRequireDefault(require("./style.scss"));

/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */
const name = 'core/text-color';
const title = (0, _i18n.__)('Text color');

function getComputedStyleProperty(element, property) {
  const {
    props: {
      style = {}
    }
  } = element;

  if (property === 'background-color') {
    var _baseColors$color;

    const {
      backgroundColor,
      baseColors
    } = style;

    if (backgroundColor !== 'transparent') {
      return backgroundColor;
    } else if (baseColors && baseColors !== null && baseColors !== void 0 && (_baseColors$color = baseColors.color) !== null && _baseColors$color !== void 0 && _baseColors$color.background) {
      var _baseColors$color2;

      return baseColors === null || baseColors === void 0 ? void 0 : (_baseColors$color2 = baseColors.color) === null || _baseColors$color2 === void 0 ? void 0 : _baseColors$color2.background;
    }

    return 'transparent';
  }
}

function fillComputedColors(element, _ref) {
  let {
    color,
    backgroundColor
  } = _ref;

  if (!color && !backgroundColor) {
    return;
  }

  return {
    color: color || getComputedStyleProperty(element, 'color'),
    backgroundColor: getComputedStyleProperty(element, 'background-color')
  };
}

function TextColorEdit(_ref2) {
  let {
    value,
    onChange,
    isActive,
    activeAttributes,
    contentRef
  } = _ref2;
  const allowCustomControl = (0, _blockEditor.useSetting)('color.custom');
  const colors = (0, _components.useMobileGlobalStylesColors)();
  const [isAddingColor, setIsAddingColor] = (0, _element.useState)(false);
  const enableIsAddingColor = (0, _element.useCallback)(() => setIsAddingColor(true), [setIsAddingColor]);
  const disableIsAddingColor = (0, _element.useCallback)(() => setIsAddingColor(false), [setIsAddingColor]);
  const colorIndicatorStyle = (0, _element.useMemo)(() => fillComputedColors(contentRef, (0, _inline.getActiveColors)(value, name, colors)), [value, colors]);
  const hasColorsToChoose = colors.length || !allowCustomControl;
  const onPressButton = (0, _element.useCallback)(() => {
    if (hasColorsToChoose) {
      enableIsAddingColor();
    } else {
      onChange((0, _richText.removeFormat)(value, name));
    }
  }, [hasColorsToChoose, value]);
  const outlineStyle = (0, _compose.usePreferredColorSchemeStyle)(_style.default['components-inline-color__outline'], _style.default['components-inline-color__outline--dark']);

  if (!hasColorsToChoose && !isActive) {
    return null;
  }

  const isActiveStyle = { ...colorIndicatorStyle,
    ...(!(colorIndicatorStyle !== null && colorIndicatorStyle !== void 0 && colorIndicatorStyle.backgroundColor) ? {
      backgroundColor: 'transparent'
    } : {}),
    ..._style.default['components-inline-color--is-active']
  };
  const customContainerStyles = _style.default['components-inline-color__button-container'];
  return (0, _element.createElement)(_element.Fragment, null, (0, _element.createElement)(_blockEditor.BlockControls, null, (0, _element.createElement)(_components.ToolbarGroup, null, isActive && (0, _element.createElement)(_reactNative.View, {
    style: outlineStyle,
    pointerEvents: "none"
  }), (0, _element.createElement)(_components.ToolbarButton, {
    name: "text-color",
    isActive: isActive,
    icon: (0, _element.createElement)(_icons.Icon, {
      icon: _icons.textColor,
      style: (colorIndicatorStyle === null || colorIndicatorStyle === void 0 ? void 0 : colorIndicatorStyle.color) && {
        color: colorIndicatorStyle.color
      }
    }),
    title: title,
    extraProps: {
      isActiveStyle,
      customContainerStyles
    } // If has no colors to choose but a color is active remove the color onClick
    ,
    onClick: onPressButton
  }))), isAddingColor && (0, _element.createElement)(_inline2.default, {
    name: name,
    onClose: disableIsAddingColor,
    activeAttributes: activeAttributes,
    value: value,
    onChange: onChange,
    contentRef: contentRef
  }));
}

const textColor = {
  name,
  title,
  tagName: 'mark',
  className: 'has-inline-color',
  attributes: {
    style: 'style',
    class: 'class'
  },

  /*
   * Since this format relies on the <mark> tag, it's important to
   * prevent the default yellow background color applied by most
   * browsers. The solution is to detect when this format is used with a
   * text color but no background color, and in such cases to override
   * the default styling with a transparent background.
   *
   * @see https://github.com/WordPress/gutenberg/pull/35516
   */
  __unstableFilterAttributeValue(key, value) {
    if (key !== 'style') return value; // We need to remove the extra spaces within the styles on mobile

    const newValue = value === null || value === void 0 ? void 0 : value.replace(/ /g, ''); // We should not add a background-color if it's already set

    if (newValue && newValue.includes('background-color')) return newValue;
    const addedCSS = ['background-color', _index.transparentValue].join(':'); // Prepend `addedCSS` to avoid a double `;;` as any the existing CSS
    // rules will already include a `;`.

    return newValue ? [addedCSS, newValue].join(';') : addedCSS;
  },

  edit: TextColorEdit
};
exports.textColor = textColor;
//# sourceMappingURL=index.native.js.map