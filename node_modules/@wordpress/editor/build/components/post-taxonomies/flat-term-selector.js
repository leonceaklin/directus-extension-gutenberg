"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.FlatTermSelector = FlatTermSelector;
exports.default = void 0;

var _element = require("@wordpress/element");

var _lodash = require("lodash");

var _escapeHtml = _interopRequireDefault(require("escape-html"));

var _i18n = require("@wordpress/i18n");

var _components = require("@wordpress/components");

var _data = require("@wordpress/data");

var _coreData = require("@wordpress/core-data");

var _compose = require("@wordpress/compose");

var _apiFetch = _interopRequireDefault(require("@wordpress/api-fetch"));

var _a11y = require("@wordpress/a11y");

var _store = require("../../store");

var _terms = require("../../utils/terms");

var _mostUsedTerms = _interopRequireDefault(require("./most-used-terms"));

/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */

/**
 * Shared reference to an empty array for cases where it is important to avoid
 * returning a new array reference on every invocation.
 *
 * @type {Array<any>}
 */
const EMPTY_ARRAY = [];
/**
 * Module constants
 */

const MAX_TERMS_SUGGESTIONS = 20;
const DEFAULT_QUERY = {
  per_page: MAX_TERMS_SUGGESTIONS,
  orderby: 'count',
  order: 'desc',
  _fields: 'id,name',
  context: 'view'
};

const isSameTermName = (termA, termB) => (0, _terms.unescapeString)(termA).toLowerCase() === (0, _terms.unescapeString)(termB).toLowerCase();

const termNamesToIds = (names, terms) => {
  return names.map(termName => terms.find(term => isSameTermName(term.name, termName)).id);
}; // Tries to create a term or fetch it if it already exists.


function findOrCreateTerm(termName, restBase, namespace) {
  const escapedTermName = (0, _escapeHtml.default)(termName);
  return (0, _apiFetch.default)({
    path: `/${namespace}/${restBase}`,
    method: 'POST',
    data: {
      name: escapedTermName
    }
  }).catch(error => {
    if (error.code !== 'term_exists') {
      return Promise.reject(error);
    }

    return Promise.resolve({
      id: error.data.term_id,
      name: termName
    });
  }).then(_terms.unescapeTerm);
}

function FlatTermSelector(_ref) {
  let {
    slug
  } = _ref;
  const [values, setValues] = (0, _element.useState)([]);
  const [search, setSearch] = (0, _element.useState)('');
  const debouncedSearch = (0, _compose.useDebounce)(setSearch, 500);
  const {
    terms,
    termIds,
    taxonomy,
    hasAssignAction,
    hasCreateAction,
    hasResolvedTerms
  } = (0, _data.useSelect)(select => {
    const {
      getCurrentPost,
      getEditedPostAttribute
    } = select(_store.store);
    const {
      getEntityRecords,
      getTaxonomy,
      hasFinishedResolution
    } = select(_coreData.store);
    const post = getCurrentPost();

    const _taxonomy = getTaxonomy(slug);

    const _termIds = _taxonomy ? getEditedPostAttribute(_taxonomy.rest_base) : EMPTY_ARRAY;

    const query = { ...DEFAULT_QUERY,
      include: _termIds.join(','),
      per_page: -1
    };
    return {
      hasCreateAction: _taxonomy ? (0, _lodash.get)(post, ['_links', 'wp:action-create-' + _taxonomy.rest_base], false) : false,
      hasAssignAction: _taxonomy ? (0, _lodash.get)(post, ['_links', 'wp:action-assign-' + _taxonomy.rest_base], false) : false,
      taxonomy: _taxonomy,
      termIds: _termIds,
      terms: _termIds.length ? getEntityRecords('taxonomy', slug, query) : EMPTY_ARRAY,
      hasResolvedTerms: hasFinishedResolution('getEntityRecords', ['taxonomy', slug, query])
    };
  }, [slug]);
  const {
    searchResults
  } = (0, _data.useSelect)(select => {
    const {
      getEntityRecords
    } = select(_coreData.store);
    return {
      searchResults: !!search ? getEntityRecords('taxonomy', slug, { ...DEFAULT_QUERY,
        search
      }) : EMPTY_ARRAY
    };
  }, [search]); // Update terms state only after the selectors are resolved.
  // We're using this to avoid terms temporarily disappearing on slow networks
  // while core data makes REST API requests.

  (0, _element.useEffect)(() => {
    if (hasResolvedTerms) {
      const newValues = (terms !== null && terms !== void 0 ? terms : []).map(term => (0, _terms.unescapeString)(term.name));
      setValues(newValues);
    }
  }, [terms, hasResolvedTerms]);
  const suggestions = (0, _element.useMemo)(() => {
    return (searchResults !== null && searchResults !== void 0 ? searchResults : []).map(term => (0, _terms.unescapeString)(term.name));
  }, [searchResults]);
  const {
    editPost
  } = (0, _data.useDispatch)(_store.store);

  if (!hasAssignAction) {
    return null;
  }

  function onUpdateTerms(newTermIds) {
    editPost({
      [taxonomy.rest_base]: newTermIds
    });
  }

  function onChange(termNames) {
    var _taxonomy$rest_namesp;

    const availableTerms = [...(terms !== null && terms !== void 0 ? terms : []), ...(searchResults !== null && searchResults !== void 0 ? searchResults : [])];
    const uniqueTerms = termNames.reduce((acc, name) => {
      if (!acc.some(n => n.toLowerCase() === name.toLowerCase())) {
        acc.push(name);
      }

      return acc;
    }, []);
    const newTermNames = uniqueTerms.filter(termName => !availableTerms.find(term => isSameTermName(term.name, termName))); // Optimistically update term values.
    // The selector will always re-fetch terms later.

    setValues(uniqueTerms);

    if (newTermNames.length === 0) {
      return onUpdateTerms(termNamesToIds(uniqueTerms, availableTerms));
    }

    if (!hasCreateAction) {
      return;
    }

    const namespace = (_taxonomy$rest_namesp = taxonomy === null || taxonomy === void 0 ? void 0 : taxonomy.rest_namespace) !== null && _taxonomy$rest_namesp !== void 0 ? _taxonomy$rest_namesp : 'wp/v2';
    Promise.all(newTermNames.map(termName => findOrCreateTerm(termName, taxonomy.rest_base, namespace))).then(newTerms => {
      const newAvailableTerms = availableTerms.concat(newTerms);
      return onUpdateTerms(termNamesToIds(uniqueTerms, newAvailableTerms));
    });
  }

  function appendTerm(newTerm) {
    if (termIds.includes(newTerm.id)) {
      return;
    }

    const newTermIds = [...termIds, newTerm.id];
    const termAddedMessage = (0, _i18n.sprintf)(
    /* translators: %s: term name. */
    (0, _i18n._x)('%s added', 'term'), (0, _lodash.get)(taxonomy, ['labels', 'singular_name'], slug === 'post_tag' ? (0, _i18n.__)('Tag') : (0, _i18n.__)('Term')));
    (0, _a11y.speak)(termAddedMessage, 'assertive');
    onUpdateTerms(newTermIds);
  }

  const newTermLabel = (0, _lodash.get)(taxonomy, ['labels', 'add_new_item'], slug === 'post_tag' ? (0, _i18n.__)('Add new tag') : (0, _i18n.__)('Add new Term'));
  const singularName = (0, _lodash.get)(taxonomy, ['labels', 'singular_name'], slug === 'post_tag' ? (0, _i18n.__)('Tag') : (0, _i18n.__)('Term'));
  const termAddedLabel = (0, _i18n.sprintf)(
  /* translators: %s: term name. */
  (0, _i18n._x)('%s added', 'term'), singularName);
  const termRemovedLabel = (0, _i18n.sprintf)(
  /* translators: %s: term name. */
  (0, _i18n._x)('%s removed', 'term'), singularName);
  const removeTermLabel = (0, _i18n.sprintf)(
  /* translators: %s: term name. */
  (0, _i18n._x)('Remove %s', 'term'), singularName);
  return (0, _element.createElement)(_element.Fragment, null, (0, _element.createElement)(_components.FormTokenField, {
    value: values,
    suggestions: suggestions,
    onChange: onChange,
    onInputChange: debouncedSearch,
    maxSuggestions: MAX_TERMS_SUGGESTIONS,
    label: newTermLabel,
    messages: {
      added: termAddedLabel,
      removed: termRemovedLabel,
      remove: removeTermLabel
    }
  }), (0, _element.createElement)(_mostUsedTerms.default, {
    taxonomy: taxonomy,
    onSelect: appendTerm
  }));
}

var _default = (0, _components.withFilters)('editor.PostTaxonomyType')(FlatTermSelector);

exports.default = _default;
//# sourceMappingURL=flat-term-selector.js.map