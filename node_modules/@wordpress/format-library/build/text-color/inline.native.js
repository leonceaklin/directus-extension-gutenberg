"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = InlineColorUI;

var _element = require("@wordpress/element");

var _richText = require("@wordpress/rich-text");

var _blockEditor = require("@wordpress/block-editor");

var _components = require("@wordpress/components");

var _index = require("./index.js");

var _inline = require("./inline.js");

/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */
function parseCSS() {
  let css = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
  return css.split(';').reduce((accumulator, rule) => {
    if (rule) {
      const [property, value] = rule.replace(/ /g, '').split(':');
      if (property === 'color') accumulator.color = value;
      if (property === 'background-color' && value !== _index.transparentValue) accumulator.backgroundColor = value;
    }

    return accumulator;
  }, {});
}

function getActiveColors(value, name, colorSettings) {
  const activeColorFormat = (0, _richText.getActiveFormat)(value, name);

  if (!activeColorFormat) {
    return {};
  }

  return { ...parseCSS(activeColorFormat.attributes.style),
    ...(0, _inline.parseClassName)(activeColorFormat.attributes.class, colorSettings)
  };
}

function setColors(value, name, colorSettings, colors) {
  const {
    color,
    backgroundColor
  } = { ...getActiveColors(value, name, colorSettings),
    ...colors
  };

  if (!color && !backgroundColor) {
    return (0, _richText.removeFormat)(value, name);
  }

  const styles = [];
  const classNames = [];
  const attributes = {};

  if (backgroundColor) {
    styles.push(['background-color', backgroundColor].join(':'));
  } else {
    // Override default browser color for mark element.
    styles.push(['background-color', _index.transparentValue].join(':'));
  }

  if (color) {
    const colorObject = (0, _blockEditor.getColorObjectByColorValue)(colorSettings, color);

    if (colorObject) {
      classNames.push((0, _blockEditor.getColorClassName)('color', colorObject.slug));
      styles.push(['color', colorObject.color].join(':'));
    } else {
      styles.push(['color', color].join(':'));
    }
  }

  if (styles.length) attributes.style = styles.join(';');
  if (classNames.length) attributes.class = classNames.join(' ');
  const format = {
    type: name,
    attributes
  };
  const hasNoSelection = value.start === value.end;
  const isAtTheEnd = value.end === value.text.length;
  const previousCharacter = value.text.charAt(value.end - 1); // Force formatting due to limitations in the native implementation

  if (hasNoSelection && (value.text.length === 0 || previousCharacter === ' ' && isAtTheEnd)) {
    // For cases where there's no text selected, there's a space before
    // the current caret position and it's at the end of the text.
    return (0, _richText.applyFormat)(value, format, value.start - 1, value.end + 1);
  } else if (hasNoSelection && isAtTheEnd) {
    // If there's no selection and is at the end of the text
    // manually add the format within the current caret position.
    const newFormat = (0, _richText.applyFormat)(value, format);
    const {
      activeFormats
    } = newFormat;
    newFormat.formats[value.start] = [...((activeFormats === null || activeFormats === void 0 ? void 0 : activeFormats.filter(_ref => {
      let {
        type
      } = _ref;
      return type !== format.type;
    })) || []), format];
    return newFormat;
  } else if (hasNoSelection) {
    return (0, _richText.removeFormat)(value, format);
  }

  return (0, _richText.applyFormat)(value, format);
}

function ColorPicker(_ref2) {
  let {
    name,
    value,
    onChange
  } = _ref2;
  const property = 'color';
  const colors = (0, _components.useMobileGlobalStylesColors)();
  const colorSettings = (0, _blockEditor.useMultipleOriginColorsAndGradients)();
  const onColorChange = (0, _element.useCallback)(color => {
    var _value$text;

    if (color !== '') {
      onChange(setColors(value, name, colors, {
        [property]: color
      })); // Remove formatting if the color was reset, there's no
      // current selection and the previous character is a space
    } else if ((value === null || value === void 0 ? void 0 : value.start) === (value === null || value === void 0 ? void 0 : value.end) && ((_value$text = value.text) === null || _value$text === void 0 ? void 0 : _value$text.charAt((value === null || value === void 0 ? void 0 : value.end) - 1)) === ' ') {
      onChange((0, _richText.removeFormat)(value, name, value.end - 1, value.end));
    } else {
      onChange((0, _richText.removeFormat)(value, name));
    }
  }, [colors, onChange, property]);
  const activeColors = (0, _element.useMemo)(() => getActiveColors(value, name, colors), [name, value, colors]);
  return (0, _element.createElement)(_components.ColorSettings, {
    colorValue: activeColors[property],
    onColorChange: onColorChange,
    defaultSettings: colorSettings,
    hideNavigation: true
  });
}

function InlineColorUI(_ref3) {
  let {
    name,
    value,
    onChange,
    onClose
  } = _ref3;
  return (0, _element.createElement)(_components.BottomSheet, {
    isVisible: true,
    onClose: onClose,
    hideHeader: true,
    contentStyle: {
      paddingLeft: 0,
      paddingRight: 0
    },
    hasNavigation: true,
    leftButton: null,
    testID: "inline-text-color-modal"
  }, (0, _element.createElement)(_components.BottomSheet.NavigationContainer, {
    animate: true,
    main: true
  }, (0, _element.createElement)(_components.BottomSheet.NavigationScreen, {
    name: "text-color"
  }, (0, _element.createElement)(ColorPicker, {
    name: name,
    value: value,
    onChange: onChange
  }))));
}
//# sourceMappingURL=inline.native.js.map