{"version":3,"sources":["@wordpress/format-library/src/link/utils.js"],"names":["getProtocol","isValidProtocol","getAuthority","isValidAuthority","getPath","isValidPath","getQueryString","isValidQueryString","getFragment","isValidFragment","isValidHref","href","trimmedHref","trim","test","protocol","startsWith","authority","path","queryString","fragment","createLinkFormat","url","type","id","opensInNewWindow","format","attributes","target","rel","getFormatBoundary","value","startIndex","start","endIndex","end","EMPTY_BOUNDARIES","formats","targetFormat","initialIndex","length","newFormats","slice","formatAtStart","find","formatAtEnd","formatAtEndMinusOne","index","indexOf","walkingArgs","walkToStart","walkToEnd","walkToBoundary","targetFormatRef","formatIndex","direction","directions","forwards","backwards","directionIncrement","inverseDirectionIncrement","partialRight","fn","partialArgs","args"],"mappings":"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","sourcesContent":["/**\n * WordPress dependencies\n */\nimport {\n\tgetProtocol,\n\tisValidProtocol,\n\tgetAuthority,\n\tisValidAuthority,\n\tgetPath,\n\tisValidPath,\n\tgetQueryString,\n\tisValidQueryString,\n\tgetFragment,\n\tisValidFragment,\n} from '@wordpress/url';\n\n/**\n * Check for issues with the provided href.\n *\n * @param {string} href The href.\n *\n * @return {boolean} Is the href invalid?\n */\nexport function isValidHref( href ) {\n\tif ( ! href ) {\n\t\treturn false;\n\t}\n\n\tconst trimmedHref = href.trim();\n\n\tif ( ! trimmedHref ) {\n\t\treturn false;\n\t}\n\n\t// Does the href start with something that looks like a URL protocol?\n\tif ( /^\\S+:/.test( trimmedHref ) ) {\n\t\tconst protocol = getProtocol( trimmedHref );\n\t\tif ( ! isValidProtocol( protocol ) ) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Add some extra checks for http(s) URIs, since these are the most common use-case.\n\t\t// This ensures URIs with an http protocol have exactly two forward slashes following the protocol.\n\t\tif (\n\t\t\tprotocol.startsWith( 'http' ) &&\n\t\t\t! /^https?:\\/\\/[^\\/\\s]/i.test( trimmedHref )\n\t\t) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst authority = getAuthority( trimmedHref );\n\t\tif ( ! isValidAuthority( authority ) ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst path = getPath( trimmedHref );\n\t\tif ( path && ! isValidPath( path ) ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst queryString = getQueryString( trimmedHref );\n\t\tif ( queryString && ! isValidQueryString( queryString ) ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst fragment = getFragment( trimmedHref );\n\t\tif ( fragment && ! isValidFragment( fragment ) ) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t// Validate anchor links.\n\tif ( trimmedHref.startsWith( '#' ) && ! isValidFragment( trimmedHref ) ) {\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\n/**\n * Generates the format object that will be applied to the link text.\n *\n * @param {Object}  options\n * @param {string}  options.url              The href of the link.\n * @param {string}  options.type             The type of the link.\n * @param {string}  options.id               The ID of the link.\n * @param {boolean} options.opensInNewWindow Whether this link will open in a new window.\n *\n * @return {Object} The final format object.\n */\nexport function createLinkFormat( { url, type, id, opensInNewWindow } ) {\n\tconst format = {\n\t\ttype: 'core/link',\n\t\tattributes: {\n\t\t\turl,\n\t\t},\n\t};\n\n\tif ( type ) format.attributes.type = type;\n\tif ( id ) format.attributes.id = id;\n\n\tif ( opensInNewWindow ) {\n\t\tformat.attributes.target = '_blank';\n\t\tformat.attributes.rel = 'noreferrer noopener';\n\t}\n\n\treturn format;\n}\n\n/* eslint-disable jsdoc/no-undefined-types */\n/**\n * Get the start and end boundaries of a given format from a rich text value.\n *\n *\n * @param {RichTextValue} value      the rich text value to interrogate.\n * @param {string}        format     the identifier for the target format (e.g. `core/link`, `core/bold`).\n * @param {number?}       startIndex optional startIndex to seek from.\n * @param {number?}       endIndex   optional endIndex to seek from.\n * @return {Object}\tobject containing start and end values for the given format.\n */\n/* eslint-enable jsdoc/no-undefined-types */\nexport function getFormatBoundary(\n\tvalue,\n\tformat,\n\tstartIndex = value.start,\n\tendIndex = value.end\n) {\n\tconst EMPTY_BOUNDARIES = {\n\t\tstart: null,\n\t\tend: null,\n\t};\n\n\tconst { formats } = value;\n\tlet targetFormat;\n\tlet initialIndex;\n\n\tif ( ! formats?.length ) {\n\t\treturn EMPTY_BOUNDARIES;\n\t}\n\n\t// Clone formats to avoid modifying source formats.\n\tconst newFormats = formats.slice();\n\n\tconst formatAtStart = newFormats[ startIndex ]?.find(\n\t\t( { type } ) => type === format.type\n\t);\n\n\tconst formatAtEnd = newFormats[ endIndex ]?.find(\n\t\t( { type } ) => type === format.type\n\t);\n\n\tconst formatAtEndMinusOne = newFormats[ endIndex - 1 ]?.find(\n\t\t( { type } ) => type === format.type\n\t);\n\n\tif ( !! formatAtStart ) {\n\t\t// Set values to conform to \"start\"\n\t\ttargetFormat = formatAtStart;\n\t\tinitialIndex = startIndex;\n\t} else if ( !! formatAtEnd ) {\n\t\t// Set values to conform to \"end\"\n\t\ttargetFormat = formatAtEnd;\n\t\tinitialIndex = endIndex;\n\t} else if ( !! formatAtEndMinusOne ) {\n\t\t// This is an edge case which will occur if you create a format, then place\n\t\t// the caret just before the format and hit the back ARROW key. The resulting\n\t\t// value object will have start and end +1 beyond the edge of the format boundary.\n\t\ttargetFormat = formatAtEndMinusOne;\n\t\tinitialIndex = endIndex - 1;\n\t} else {\n\t\treturn EMPTY_BOUNDARIES;\n\t}\n\n\tconst index = newFormats[ initialIndex ].indexOf( targetFormat );\n\n\tconst walkingArgs = [ newFormats, initialIndex, targetFormat, index ];\n\n\t// Walk the startIndex \"backwards\" to the leading \"edge\" of the matching format.\n\tstartIndex = walkToStart( ...walkingArgs );\n\n\t// Walk the endIndex \"forwards\" until the trailing \"edge\" of the matching format.\n\tendIndex = walkToEnd( ...walkingArgs );\n\n\t// Safe guard: start index cannot be less than 0.\n\tstartIndex = startIndex < 0 ? 0 : startIndex;\n\n\t// // Return the indicies of the \"edges\" as the boundaries.\n\treturn {\n\t\tstart: startIndex,\n\t\tend: endIndex,\n\t};\n}\n\n/**\n * Walks forwards/backwards towards the boundary of a given format within an\n * array of format objects. Returns the index of the boundary.\n *\n * @param {Array}  formats         the formats to search for the given format type.\n * @param {number} initialIndex    the starting index from which to walk.\n * @param {Object} targetFormatRef a reference to the format type object being sought.\n * @param {number} formatIndex     the index at which we expect the target format object to be.\n * @param {string} direction       either 'forwards' or 'backwards' to indicate the direction.\n * @return {number} the index of the boundary of the given format.\n */\nfunction walkToBoundary(\n\tformats,\n\tinitialIndex,\n\ttargetFormatRef,\n\tformatIndex,\n\tdirection\n) {\n\tlet index = initialIndex;\n\n\tconst directions = {\n\t\tforwards: 1,\n\t\tbackwards: -1,\n\t};\n\n\tconst directionIncrement = directions[ direction ] || 1; // invalid direction arg default to forwards\n\tconst inverseDirectionIncrement = directionIncrement * -1;\n\n\twhile (\n\t\tformats[ index ] &&\n\t\tformats[ index ][ formatIndex ] === targetFormatRef\n\t) {\n\t\t// Increment/decrement in the direction of operation.\n\t\tindex = index + directionIncrement;\n\t}\n\n\t// Restore by one in inverse direction of operation\n\t// to avoid out of bounds.\n\tindex = index + inverseDirectionIncrement;\n\n\treturn index;\n}\n\nconst partialRight =\n\t( fn, ...partialArgs ) =>\n\t( ...args ) =>\n\t\tfn( ...args, ...partialArgs );\n\nconst walkToStart = partialRight( walkToBoundary, 'backwards' );\n\nconst walkToEnd = partialRight( walkToBoundary, 'forwards' );\n"]}