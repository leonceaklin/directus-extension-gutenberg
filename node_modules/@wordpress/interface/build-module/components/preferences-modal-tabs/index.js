import { createElement } from "@wordpress/element";

/**
 * WordPress dependencies
 */
import { useViewportMatch } from '@wordpress/compose';
import { __experimentalNavigatorProvider as NavigatorProvider, __experimentalNavigatorScreen as NavigatorScreen, __experimentalNavigatorButton as NavigatorButton, __experimentalNavigatorBackButton as NavigatorBackButton, __experimentalItemGroup as ItemGroup, __experimentalItem as Item, __experimentalHStack as HStack, __experimentalText as Text, __experimentalTruncate as Truncate, FlexItem, TabPanel, Card, CardHeader, CardBody } from '@wordpress/components';
import { useMemo, useCallback, useState } from '@wordpress/element';
import { chevronLeft, chevronRight, Icon } from '@wordpress/icons';
import { isRTL, __ } from '@wordpress/i18n';
const PREFERENCES_MENU = 'preferences-menu';
export default function PreferencesModalTabs(_ref) {
  let {
    sections
  } = _ref;
  const isLargeViewport = useViewportMatch('medium'); // This is also used to sync the two different rendered components
  // between small and large viewports.

  const [activeMenu, setActiveMenu] = useState(PREFERENCES_MENU);
  /**
   * Create helper objects from `sections` for easier data handling.
   * `tabs` is used for creating the `TabPanel` and `sectionsContentMap`
   * is used for easier access to active tab's content.
   */

  const {
    tabs,
    sectionsContentMap
  } = useMemo(() => {
    let mappedTabs = {
      tabs: [],
      sectionsContentMap: {}
    };

    if (sections.length) {
      mappedTabs = sections.reduce((accumulator, _ref2) => {
        let {
          name,
          tabLabel: title,
          content
        } = _ref2;
        accumulator.tabs.push({
          name,
          title
        });
        accumulator.sectionsContentMap[name] = content;
        return accumulator;
      }, {
        tabs: [],
        sectionsContentMap: {}
      });
    }

    return mappedTabs;
  }, [sections]);
  const getCurrentTab = useCallback(tab => sectionsContentMap[tab.name] || null, [sectionsContentMap]);
  let modalContent; // We render different components based on the viewport size.

  if (isLargeViewport) {
    modalContent = createElement(TabPanel, {
      className: "interface-preferences__tabs",
      tabs: tabs,
      initialTabName: activeMenu !== PREFERENCES_MENU ? activeMenu : undefined,
      onSelect: setActiveMenu,
      orientation: "vertical"
    }, getCurrentTab);
  } else {
    modalContent = createElement(NavigatorProvider, {
      initialPath: "/",
      className: "interface-preferences__provider"
    }, createElement(NavigatorScreen, {
      path: "/"
    }, createElement(Card, {
      isBorderless: true,
      size: "small"
    }, createElement(CardBody, null, createElement(ItemGroup, null, tabs.map(tab => {
      return createElement(NavigatorButton, {
        key: tab.name,
        path: tab.name,
        as: Item,
        isAction: true
      }, createElement(HStack, {
        justify: "space-between"
      }, createElement(FlexItem, null, createElement(Truncate, null, tab.title)), createElement(FlexItem, null, createElement(Icon, {
        icon: isRTL() ? chevronLeft : chevronRight
      }))));
    }))))), sections.length && sections.map(section => {
      return createElement(NavigatorScreen, {
        key: `${section.name}-menu`,
        path: section.name
      }, createElement(Card, {
        isBorderless: true,
        size: "large"
      }, createElement(CardHeader, {
        isBorderless: false,
        justify: "left",
        size: "small",
        gap: "6"
      }, createElement(NavigatorBackButton, {
        icon: isRTL() ? chevronRight : chevronLeft,
        "aria-label": __('Navigate to the previous view')
      }), createElement(Text, {
        size: "16"
      }, section.tabLabel)), createElement(CardBody, null, section.content)));
    }));
  }

  return modalContent;
}
//# sourceMappingURL=index.js.map